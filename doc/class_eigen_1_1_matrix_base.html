<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>NumCpp: Eigen::MatrixBase&lt; Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NumCpp
   &#160;<span id="projectnumber">0.1alpha</span>
   </div>
   <div id="projectbrief">Multidimensional Array library for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Eigen</b></li><li class="navelem"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_eigen_1_1_matrix_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::MatrixBase&lt; Derived &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_matrix_base_8h_source.html">MatrixBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Eigen::MatrixBase&lt; Derived &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_eigen_1_1_matrix_base.png" usemap="#Eigen::MatrixBase&lt; Derived &gt;_map" alt=""/>
  <map id="Eigen::MatrixBase&lt; Derived &gt;_map" name="Eigen::MatrixBase&lt; Derived &gt;_map">
<area href="class_eigen_1_1_dense_base.html" title="Base class for all dense matrices, vectors, and arrays." alt="Eigen::DenseBase&lt; Derived &gt;" shape="rect" coords="0,0,183,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3cf75a9110a1a28c493e124c8a7fcade"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, <br class="typebreak"/>
EIGEN_SIZE_MAX(<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>), <br class="typebreak"/>
EIGEN_SIZE_MAX(<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3cf75a9110a1a28c493e124c8a7fcade">SquareMatrixType</a></td></tr>
<tr class="separator:a3cf75a9110a1a28c493e124c8a7fcade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02545f8c3f4551e949c1ea0517a0d41c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; typename <br class="typebreak"/>
internal::traits&lt; Derived &gt;<br class="typebreak"/>
::Scalar, internal::traits<br class="typebreak"/>
&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <br class="typebreak"/>
internal::traits&lt; Derived &gt;<br class="typebreak"/>
::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, AutoAlign|(internal::traits<br class="typebreak"/>
&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> <br class="typebreak"/>
&amp;RowMajorBit?RowMajor:ColMajor), <br class="typebreak"/>
internal::traits&lt; Derived &gt;<br class="typebreak"/>
::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, <br class="typebreak"/>
internal::traits&lt; Derived &gt;<br class="typebreak"/>
::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfacc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a></td></tr>
<tr class="separator:a02545f8c3f4551e949c1ea0517a0d41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_eigen_1_1_dense_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_eigen_1_1_dense_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_eigen_1_1_dense_base.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a955028c4d9181328a799a9ac6b5068bf inherit pub_types_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a> = internal::traits&lt;Derived&gt;::RowsAtCompileTime, 
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a> = internal::traits&lt;Derived&gt;::ColsAtCompileTime, 
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, 
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a> = internal::traits&lt;Derived&gt;::MaxRowsAtCompileTime, 
<br/>
&#160;&#160;<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfacc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> = internal::traits&lt;Derived&gt;::MaxColsAtCompileTime, 
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a>, 
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa1156955c8099c5072934b74c72654ed0">IsVectorAtCompileTime</a>, 
<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> = internal::traits&lt;Derived&gt;::Flags, 
<br/>
&#160;&#160;<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> = int(Flags) &amp; RowMajorBit
, <a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa5ffb8ac02e2095b4ebb7c9d001252bee">CoeffReadCost</a> = internal::traits&lt;Derived&gt;::CoeffReadCost
<br/>
 }</td></tr>
<tr class="separator:a955028c4d9181328a799a9ac6b5068bf inherit pub_types_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad772e0ab2eb84b25cec6410631e8fdde inherit pub_types_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">typedef internal::traits<br class="typebreak"/>
&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a></td></tr>
<tr class="separator:ad772e0ab2eb84b25cec6410631e8fdde inherit pub_types_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b9b16405d3aa78bb634df74497af05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a1b9b16405d3aa78bb634df74497af05e">diagonalSize</a> () const </td></tr>
<tr class="separator:a1b9b16405d3aa78bb634df74497af05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88c754cead815f8e40e006457a618e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_opposite_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; Derived &gt;::Scalar &gt;, const <br class="typebreak"/>
Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae88c754cead815f8e40e006457a618e2">operator-</a> () const </td></tr>
<tr class="separator:ae88c754cead815f8e40e006457a618e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b10cc7219c481fa40db0bb5781f56a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">ScalarMultipleReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a30b10cc7219c481fa40db0bb5781f56a">operator*</a> (const Scalar &amp;scalar) const </td></tr>
<tr class="separator:a30b10cc7219c481fa40db0bb5781f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57482610af9f8a69baa0eb4f376d7b85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient1_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; Derived &gt;::Scalar &gt;, const <br class="typebreak"/>
Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a57482610af9f8a69baa0eb4f376d7b85">operator/</a> (const Scalar &amp;scalar) const </td></tr>
<tr class="separator:a57482610af9f8a69baa0eb4f376d7b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da22f27a3829b54c096f655283d7ae0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_multiple2_op<br class="typebreak"/>
&lt; Scalar, std::complex&lt; Scalar &gt;<br class="typebreak"/>
 &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3da22f27a3829b54c096f655283d7ae0">operator*</a> (const std::complex&lt; Scalar &gt; &amp;scalar) const </td></tr>
<tr class="separator:a3da22f27a3829b54c096f655283d7ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b476d26afcd3d6d99282efe43d4a04d"><td class="memTemplParams" colspan="2">template&lt;typename NewType &gt; </td></tr>
<tr class="memitem:a4b476d26afcd3d6d99282efe43d4a04d"><td class="memTemplItemLeft" align="right" valign="top">internal::cast_return_type<br class="typebreak"/>
&lt; Derived, const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_cast_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; Derived &gt;::Scalar, NewType &gt;<br class="typebreak"/>
, const Derived &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a4b476d26afcd3d6d99282efe43d4a04d">cast</a> () const </td></tr>
<tr class="separator:a4b476d26afcd3d6d99282efe43d4a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53e8680069efaf279a7b822e068d6d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">ConjugateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae53e8680069efaf279a7b822e068d6d4">conjugate</a> () const </td></tr>
<tr class="separator:ae53e8680069efaf279a7b822e068d6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10353dcb54de8fbe27619cffd7fced5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">RealReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad10353dcb54de8fbe27619cffd7fced5">real</a> () const </td></tr>
<tr class="separator:ad10353dcb54de8fbe27619cffd7fced5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c62c9f2e33ddfe33d53c4d8a3b0d485"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">ImagReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a5c62c9f2e33ddfe33d53c4d8a3b0d485">imag</a> () const </td></tr>
<tr class="separator:a5c62c9f2e33ddfe33d53c4d8a3b0d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe602d55aa168bfbc48b71524f0710b"><td class="memTemplParams" colspan="2">template&lt;typename CustomUnaryOp &gt; </td></tr>
<tr class="memitem:acbe602d55aa168bfbc48b71524f0710b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; CustomUnaryOp, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#acbe602d55aa168bfbc48b71524f0710b">unaryExpr</a> (const CustomUnaryOp &amp;func=CustomUnaryOp()) const </td></tr>
<tr class="separator:acbe602d55aa168bfbc48b71524f0710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684d4b2ab4e7e9ed45ea2c4d78c16010"><td class="memTemplParams" colspan="2">template&lt;typename CustomViewOp &gt; </td></tr>
<tr class="memitem:a684d4b2ab4e7e9ed45ea2c4d78c16010"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_view.html">CwiseUnaryView</a><br class="typebreak"/>
&lt; CustomViewOp, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a684d4b2ab4e7e9ed45ea2c4d78c16010">unaryViewExpr</a> (const CustomViewOp &amp;func=CustomViewOp()) const </td></tr>
<tr class="separator:a684d4b2ab4e7e9ed45ea2c4d78c16010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba1be140ede8b142460b325945c551f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">NonConstRealReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aeba1be140ede8b142460b325945c551f">real</a> ()</td></tr>
<tr class="separator:aeba1be140ede8b142460b325945c551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae468f7f102d5f04f20b2c0afe6eb0f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_cwise_unary_view.html">NonConstImagReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae468f7f102d5f04f20b2c0afe6eb0f82">imag</a> ()</td></tr>
<tr class="separator:ae468f7f102d5f04f20b2c0afe6eb0f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b5c6cebebe3c6b70eb64dfbaa6fb13"><td class="memTemplParams" colspan="2">template&lt;typename CustomBinaryOp , typename OtherDerived &gt; </td></tr>
<tr class="memitem:a13b5c6cebebe3c6b70eb64dfbaa6fb13"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt; CustomBinaryOp, <br class="typebreak"/>
const Derived, const <br class="typebreak"/>
OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a13b5c6cebebe3c6b70eb64dfbaa6fb13">binaryExpr</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const CustomBinaryOp &amp;func=CustomBinaryOp()) const </td></tr>
<tr class="separator:a13b5c6cebebe3c6b70eb64dfbaa6fb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f273a7dd8a5516efc6f341b54bb8da9"><td class="memItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_abs_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3f273a7dd8a5516efc6f341b54bb8da9">cwiseAbs</a> () const </td></tr>
<tr class="separator:a3f273a7dd8a5516efc6f341b54bb8da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cb4a5267895e3abb29c309448f0c48"><td class="memItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_abs2_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aa3cb4a5267895e3abb29c309448f0c48">cwiseAbs2</a> () const </td></tr>
<tr class="separator:aa3cb4a5267895e3abb29c309448f0c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95b94aabe162300d6d70a7c7d762751"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_sqrt_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aa95b94aabe162300d6d70a7c7d762751">cwiseSqrt</a> () const </td></tr>
<tr class="separator:aa95b94aabe162300d6d70a7c7d762751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111ce244aeb4698ae56604f8d211032"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_inverse_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a6111ce244aeb4698ae56604f8d211032">cwiseInverse</a> () const </td></tr>
<tr class="separator:a6111ce244aeb4698ae56604f8d211032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d992e31d479d0c4e6d47f7bab493ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; std::binder1st<br class="typebreak"/>
&lt; std::equal_to&lt; Scalar &gt;<br class="typebreak"/>
 &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae7d992e31d479d0c4e6d47f7bab493ba">cwiseEqual</a> (const Scalar &amp;s) const </td></tr>
<tr class="separator:ae7d992e31d479d0c4e6d47f7bab493ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0644598abdc92e666504f710ac9fda2"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aa0644598abdc92e666504f710ac9fda2"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aa0644598abdc92e666504f710ac9fda2">EIGEN_CWISE_PRODUCT_RETURN_TYPE</a> (Derived, OtherDerived) cwiseProduct(const Eigen</td></tr>
<tr class="separator:aa0644598abdc92e666504f710ac9fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a92b34afd2680074f5222f2b41cb5e"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ad0a92b34afd2680074f5222f2b41cb5e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; std::equal_to&lt; Scalar &gt;<br class="typebreak"/>
, const Derived, const <br class="typebreak"/>
OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad0a92b34afd2680074f5222f2b41cb5e">cwiseEqual</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:ad0a92b34afd2680074f5222f2b41cb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74a7bd14e28fc41c28c3a89de8eb441"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af74a7bd14e28fc41c28c3a89de8eb441"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; std::not_equal_to&lt; Scalar &gt;<br class="typebreak"/>
, const Derived, const <br class="typebreak"/>
OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#af74a7bd14e28fc41c28c3a89de8eb441">cwiseNotEqual</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:af74a7bd14e28fc41c28c3a89de8eb441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9971741beb0966b2cfbe10af0eee20f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ab9971741beb0966b2cfbe10af0eee20f"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_min_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived, <br class="typebreak"/>
const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ab9971741beb0966b2cfbe10af0eee20f">cwiseMin</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:ab9971741beb0966b2cfbe10af0eee20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec7680109788bfa5a366ddd7e7a33e"><td class="memItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_min_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived, <br class="typebreak"/>
const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#acbec7680109788bfa5a366ddd7e7a33e">cwiseMin</a> (const Scalar &amp;other) const </td></tr>
<tr class="separator:acbec7680109788bfa5a366ddd7e7a33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdafef370036f7161371e959242a25c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:abcdafef370036f7161371e959242a25c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_max_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived, <br class="typebreak"/>
const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#abcdafef370036f7161371e959242a25c">cwiseMax</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:abcdafef370036f7161371e959242a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b65e9413b8b9bb21a57ac7b3154811"><td class="memItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_max_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived, <br class="typebreak"/>
const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ab7b65e9413b8b9bb21a57ac7b3154811">cwiseMax</a> (const Scalar &amp;other) const </td></tr>
<tr class="separator:ab7b65e9413b8b9bb21a57ac7b3154811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0274c10f4f3e1cb1f66225a660ad178b"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a0274c10f4f3e1cb1f66225a660ad178b"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient_op<br class="typebreak"/>
&lt; Scalar &gt;, const Derived, <br class="typebreak"/>
const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a0274c10f4f3e1cb1f66225a660ad178b">cwiseQuotient</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:a0274c10f4f3e1cb1f66225a660ad178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da30d0cb9a52a8b39e59d76b1765952"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a0da30d0cb9a52a8b39e59d76b1765952">operator=</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a0da30d0cb9a52a8b39e59d76b1765952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c1c2392d6d04b552a478ec3f82c511"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af8c1c2392d6d04b552a478ec3f82c511"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#af8c1c2392d6d04b552a478ec3f82c511">operator+=</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:af8c1c2392d6d04b552a478ec3f82c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3955c1440eacc31034a9b0ba61bd055"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae3955c1440eacc31034a9b0ba61bd055"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae3955c1440eacc31034a9b0ba61bd055">operator-=</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ae3955c1440eacc31034a9b0ba61bd055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772e2b44c48aa96996febcb9b05b8215"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a772e2b44c48aa96996febcb9b05b8215"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_eigen_1_1_product_return_type.html">ProductReturnType</a><br class="typebreak"/>
&lt; Derived, OtherDerived &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a772e2b44c48aa96996febcb9b05b8215">operator*</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:a772e2b44c48aa96996febcb9b05b8215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7855bab2b66967edd4b9b38f63bbb73"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ad7855bab2b66967edd4b9b38f63bbb73"><td class="memTemplItemLeft" align="right" valign="top">const LazyProductReturnType<br class="typebreak"/>
&lt; Derived, OtherDerived &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad7855bab2b66967edd4b9b38f63bbb73">lazyProduct</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:ad7855bab2b66967edd4b9b38f63bbb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3783b6168995ca117a1c19fea3630ac4"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3783b6168995ca117a1c19fea3630ac4"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3783b6168995ca117a1c19fea3630ac4">operator*=</a> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a3783b6168995ca117a1c19fea3630ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08ad41e81d8ad4a37b5d5c7490e765"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3a08ad41e81d8ad4a37b5d5c7490e765"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3a08ad41e81d8ad4a37b5d5c7490e765">applyOnTheLeft</a> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a3a08ad41e81d8ad4a37b5d5c7490e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d91752925d2757fc8058a293b15462"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a45d91752925d2757fc8058a293b15462"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a45d91752925d2757fc8058a293b15462">applyOnTheRight</a> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a45d91752925d2757fc8058a293b15462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de55e67af91d0bc9fc077a4a3029f2d"><td class="memTemplParams" colspan="2">template&lt;typename DiagonalDerived &gt; </td></tr>
<tr class="memitem:a7de55e67af91d0bc9fc077a4a3029f2d"><td class="memTemplItemLeft" align="right" valign="top">const DiagonalProduct&lt; Derived, <br class="typebreak"/>
DiagonalDerived, OnTheRight &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a7de55e67af91d0bc9fc077a4a3029f2d">operator*</a> (const DiagonalBase&lt; DiagonalDerived &gt; &amp;<a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">diagonal</a>) const </td></tr>
<tr class="separator:a7de55e67af91d0bc9fc077a4a3029f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ab02d921af5783310144383c285fc"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a710ab02d921af5783310144383c285fc"><td class="memTemplItemLeft" align="right" valign="top">internal::scalar_product_traits<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; Derived &gt;::Scalar, typename <br class="typebreak"/>
internal::traits&lt; OtherDerived &gt;<br class="typebreak"/>
::Scalar &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a710ab02d921af5783310144383c285fc">dot</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:a710ab02d921af5783310144383c285fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff809586e6babaa7821d5978517989d6"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aff809586e6babaa7821d5978517989d6">squaredNorm</a> () const </td></tr>
<tr class="separator:aff809586e6babaa7821d5978517989d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c247d700df304eb9a560bab60335ee1"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm</a> () const </td></tr>
<tr class="separator:a8c247d700df304eb9a560bab60335ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2491064a05310dd3f331eac31e8aba"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a7f2491064a05310dd3f331eac31e8aba">stableNorm</a> () const </td></tr>
<tr class="separator:a7f2491064a05310dd3f331eac31e8aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c25fe03a20483e148eeaf800e5c94e"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad1c25fe03a20483e148eeaf800e5c94e">blueNorm</a> () const </td></tr>
<tr class="separator:ad1c25fe03a20483e148eeaf800e5c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6da450b7538549cfc5d4a9e3cf1ffa"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ade6da450b7538549cfc5d4a9e3cf1ffa">hypotNorm</a> () const </td></tr>
<tr class="separator:ade6da450b7538549cfc5d4a9e3cf1ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680e8b0963abb141fc572c2d37d0496a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a680e8b0963abb141fc572c2d37d0496a">normalized</a> () const </td></tr>
<tr class="separator:a680e8b0963abb141fc572c2d37d0496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16303c47ba36f7a41ea264cb26bceb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad16303c47ba36f7a41ea264cb26bceb6">normalize</a> ()</td></tr>
<tr class="separator:ad16303c47ba36f7a41ea264cb26bceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab76dee1a5bf179ad4dcaa437179851"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">AdjointReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3ab76dee1a5bf179ad4dcaa437179851">adjoint</a> () const </td></tr>
<tr class="separator:a3ab76dee1a5bf179ad4dcaa437179851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c5982c1f64e45a939515b701fa6f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a51c5982c1f64e45a939515b701fa6f4a">adjointInPlace</a> ()</td></tr>
<tr class="separator:a51c5982c1f64e45a939515b701fa6f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0af691da3743e8a0154dfdebef745fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_diagonal.html">DiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">diagonal</a> ()</td></tr>
<tr class="separator:ad0af691da3743e8a0154dfdebef745fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82c14e48e0158255dc1e8ddbee13f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_diagonal.html">ConstDiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aa82c14e48e0158255dc1e8ddbee13f54">diagonal</a> () const </td></tr>
<tr class="separator:aa82c14e48e0158255dc1e8ddbee13f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc484e35fe942b1311731ed98caa5fe0"><td class="memItemLeft" align="right" valign="top">DiagonalIndexReturnType<br class="typebreak"/>
&lt; Dynamic &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#adc484e35fe942b1311731ed98caa5fe0">diagonal</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> index)</td></tr>
<tr class="separator:adc484e35fe942b1311731ed98caa5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cac003afc562e2c3362eef006c67da"><td class="memItemLeft" align="right" valign="top">ConstDiagonalIndexReturnType<br class="typebreak"/>
&lt; Dynamic &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae2cac003afc562e2c3362eef006c67da">diagonal</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> index) const </td></tr>
<tr class="separator:ae2cac003afc562e2c3362eef006c67da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be7b9dfc5dc6f201f9267f7c1cb950"><td class="memTemplParams" colspan="2">template&lt;unsigned int Mode&gt; </td></tr>
<tr class="memitem:a09be7b9dfc5dc6f201f9267f7c1cb950"><td class="memTemplItemLeft" align="right" valign="top">TriangularViewReturnType&lt; Mode &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a09be7b9dfc5dc6f201f9267f7c1cb950">triangularView</a> ()</td></tr>
<tr class="separator:a09be7b9dfc5dc6f201f9267f7c1cb950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f8b54a684c1b18c5b7a23b94f6a612"><td class="memTemplParams" colspan="2">template&lt;unsigned int Mode&gt; </td></tr>
<tr class="memitem:a10f8b54a684c1b18c5b7a23b94f6a612"><td class="memTemplItemLeft" align="right" valign="top">ConstTriangularViewReturnType<br class="typebreak"/>
&lt; Mode &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a10f8b54a684c1b18c5b7a23b94f6a612">triangularView</a> () const </td></tr>
<tr class="separator:a10f8b54a684c1b18c5b7a23b94f6a612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab757d5801a0e038f8555635f06456352"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a>&lt; const <br class="typebreak"/>
Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ab757d5801a0e038f8555635f06456352">asDiagonal</a> () const </td></tr>
<tr class="separator:ab757d5801a0e038f8555635f06456352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306742007396d5350c7830b1c3bebfbc"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a306742007396d5350c7830b1c3bebfbc">setIdentity</a> ()</td></tr>
<tr class="separator:a306742007396d5350c7830b1c3bebfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0851dcc7c82753eb3e341d99b691665a"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a0851dcc7c82753eb3e341d99b691665a">setIdentity</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols)</td></tr>
<tr class="separator:a0851dcc7c82753eb3e341d99b691665a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02c24b6cece07dc777dea7a2eb67524"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae02c24b6cece07dc777dea7a2eb67524">isIdentity</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:ae02c24b6cece07dc777dea7a2eb67524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b671f154dac9f7c6d03fdb9e5f9fab4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a4b671f154dac9f7c6d03fdb9e5f9fab4">isDiagonal</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a4b671f154dac9f7c6d03fdb9e5f9fab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309cfe63c77116ebc0a3e909c767890e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a309cfe63c77116ebc0a3e909c767890e">isUpperTriangular</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a309cfe63c77116ebc0a3e909c767890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adf4d2f4b0b4c97c600e16871f8d2fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a2adf4d2f4b0b4c97c600e16871f8d2fa">isLowerTriangular</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a2adf4d2f4b0b4c97c600e16871f8d2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9adf53ddc0888a91de6e8dba56113c8"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac9adf53ddc0888a91de6e8dba56113c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ac9adf53ddc0888a91de6e8dba56113c8">isOrthogonal</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other, RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:ac9adf53ddc0888a91de6e8dba56113c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c6a2f3e6953c7dcd8e8284b3633b53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a56c6a2f3e6953c7dcd8e8284b3633b53">isUnitary</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a56c6a2f3e6953c7dcd8e8284b3633b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f55a023e88f00d8335de9ca33c881c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae5f55a023e88f00d8335de9ca33c881c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae5f55a023e88f00d8335de9ca33c881c">operator==</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:ae5f55a023e88f00d8335de9ca33c881c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7329f46e18c431c6dc5271aa4818bdb8"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a7329f46e18c431c6dc5271aa4818bdb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a7329f46e18c431c6dc5271aa4818bdb8">operator!=</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:a7329f46e18c431c6dc5271aa4818bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1085de7645f23f240876388457da0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_no_alias.html">NoAlias</a>&lt; Derived, <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a2c1085de7645f23f240876388457da0b">noalias</a> ()</td></tr>
<tr class="separator:a2c1085de7645f23f240876388457da0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963cddf8d98590ef850ba18383e89fa5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a963cddf8d98590ef850ba18383e89fa5">forceAlignedAccess</a> () const </td></tr>
<tr class="separator:a963cddf8d98590ef850ba18383e89fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaf810ac1708ca6d6ecdcfac1e06699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#afdaf810ac1708ca6d6ecdcfac1e06699">forceAlignedAccess</a> ()</td></tr>
<tr class="separator:afdaf810ac1708ca6d6ecdcfac1e06699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d6ed8808adeee9cd51da20563a9da7"><td class="memTemplParams" colspan="2">template&lt;bool Enable&gt; </td></tr>
<tr class="memitem:ad9d6ed8808adeee9cd51da20563a9da7"><td class="memTemplItemLeft" align="right" valign="top">internal::add_const_on_value_type<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
internal::conditional&lt; Enable, <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt;<br class="typebreak"/>
, Derived &amp; &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad9d6ed8808adeee9cd51da20563a9da7">forceAlignedAccessIf</a> () const </td></tr>
<tr class="separator:ad9d6ed8808adeee9cd51da20563a9da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748ec59de03a5c51cc6acd3fe1f2ca06"><td class="memTemplParams" colspan="2">template&lt;bool Enable&gt; </td></tr>
<tr class="memitem:a748ec59de03a5c51cc6acd3fe1f2ca06"><td class="memTemplItemLeft" align="right" valign="top">internal::conditional&lt; Enable, <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt;<br class="typebreak"/>
, Derived &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a748ec59de03a5c51cc6acd3fe1f2ca06">forceAlignedAccessIf</a> ()</td></tr>
<tr class="separator:a748ec59de03a5c51cc6acd3fe1f2ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1a27388d3d5b242e50ea06a0ebe866"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3b1a27388d3d5b242e50ea06a0ebe866">trace</a> () const </td></tr>
<tr class="separator:a3b1a27388d3d5b242e50ea06a0ebe866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6439765c982bbf208379b7c8dc726d"><td class="memTemplParams" colspan="2">template&lt;int p&gt; </td></tr>
<tr class="memitem:a9f6439765c982bbf208379b7c8dc726d"><td class="memTemplItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a9f6439765c982bbf208379b7c8dc726d">lpNorm</a> () const </td></tr>
<tr class="separator:a9f6439765c982bbf208379b7c8dc726d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354c33eec32ceb4193d002f4d41c0497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_array_wrapper.html">ArrayWrapper</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a354c33eec32ceb4193d002f4d41c0497">array</a> ()</td></tr>
<tr class="separator:a354c33eec32ceb4193d002f4d41c0497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08113a4812ac99b7105b7556804dca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_full_piv_l_u.html">FullPivLU</a>&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3a08113a4812ac99b7105b7556804dca">fullPivLu</a> () const </td></tr>
<tr class="separator:a3a08113a4812ac99b7105b7556804dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76ef5a9b6769b3e20ec6529cd3ca276"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_partial_piv_l_u.html">PartialPivLU</a>&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ac76ef5a9b6769b3e20ec6529cd3ca276">partialPivLu</a> () const </td></tr>
<tr class="separator:ac76ef5a9b6769b3e20ec6529cd3ca276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721714321d5f2946c13767c193739c1a"><td class="memItemLeft" align="right" valign="top">const internal::inverse_impl<br class="typebreak"/>
&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a721714321d5f2946c13767c193739c1a">inverse</a> () const </td></tr>
<tr class="separator:a721714321d5f2946c13767c193739c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a6327048607951e172ca03659ba16c"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a00a6327048607951e172ca03659ba16c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a00a6327048607951e172ca03659ba16c">computeInverseAndDetWithCheck</a> (ResultType &amp;<a class="el" href="class_eigen_1_1_matrix_base.html#a721714321d5f2946c13767c193739c1a">inverse</a>, typename ResultType::Scalar &amp;<a class="el" href="class_eigen_1_1_matrix_base.html#a683482f8bdb56f34d840dc5f531943f7">determinant</a>, bool &amp;invertible, const RealScalar &amp;absDeterminantThreshold=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a00a6327048607951e172ca03659ba16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4efbb1f5b83187d723e4f33fd3954"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a51f4efbb1f5b83187d723e4f33fd3954"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a51f4efbb1f5b83187d723e4f33fd3954">computeInverseWithCheck</a> (ResultType &amp;<a class="el" href="class_eigen_1_1_matrix_base.html#a721714321d5f2946c13767c193739c1a">inverse</a>, bool &amp;invertible, const RealScalar &amp;absDeterminantThreshold=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a51f4efbb1f5b83187d723e4f33fd3954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683482f8bdb56f34d840dc5f531943f7"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a683482f8bdb56f34d840dc5f531943f7">determinant</a> () const </td></tr>
<tr class="separator:a683482f8bdb56f34d840dc5f531943f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6655385ff1d96c949f0690ef88bdef6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_l_l_t.html">LLT</a>&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a6655385ff1d96c949f0690ef88bdef6a">llt</a> () const </td></tr>
<tr class="separator:a6655385ff1d96c949f0690ef88bdef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6952b6c24cfbd171f6e3774098a7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_l_d_l_t.html">LDLT</a>&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3ac6952b6c24cfbd171f6e3774098a7c">ldlt</a> () const </td></tr>
<tr class="separator:a3ac6952b6c24cfbd171f6e3774098a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c181bbbb7457c6cfa5f31a73ab8c070"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_householder_q_r.html">HouseholderQR</a>&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a1c181bbbb7457c6cfa5f31a73ab8c070">householderQr</a> () const </td></tr>
<tr class="separator:a1c181bbbb7457c6cfa5f31a73ab8c070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914ea9742e139148b2b1a0b13d2280e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_col_piv_householder_q_r.html">ColPivHouseholderQR</a><br class="typebreak"/>
&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a914ea9742e139148b2b1a0b13d2280e9">colPivHouseholderQr</a> () const </td></tr>
<tr class="separator:a914ea9742e139148b2b1a0b13d2280e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35969f2f99e43ba78ed63d5e941f89ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_full_piv_householder_q_r.html">FullPivHouseholderQR</a><br class="typebreak"/>
&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a35969f2f99e43ba78ed63d5e941f89ca">fullPivHouseholderQr</a> () const </td></tr>
<tr class="separator:a35969f2f99e43ba78ed63d5e941f89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe1f257e53611dc9ca1a7e9fe81854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix.html">EigenvaluesReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#adbfe1f257e53611dc9ca1a7e9fe81854">eigenvalues</a> () const </td></tr>
<tr class="separator:adbfe1f257e53611dc9ca1a7e9fe81854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11574afb358726e20951701e4190f337"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a11574afb358726e20951701e4190f337">operatorNorm</a> () const </td></tr>
<tr class="separator:a11574afb358726e20951701e4190f337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662630cec4376bb127527856382828a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_jacobi_s_v_d.html">JacobiSVD</a>&lt; <a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a662630cec4376bb127527856382828a9">jacobiSvd</a> (unsigned int computationOptions=0) const </td></tr>
<tr class="separator:a662630cec4376bb127527856382828a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b453529e54476b660575bcfcd51d3a"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a67b453529e54476b660575bcfcd51d3a"><td class="memTemplItemLeft" align="right" valign="top">cross_product_return_type<br class="typebreak"/>
&lt; OtherDerived &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a67b453529e54476b660575bcfcd51d3a">cross</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:a67b453529e54476b660575bcfcd51d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8416e098f4a05f7576993933e0542153"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a8416e098f4a05f7576993933e0542153"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a8416e098f4a05f7576993933e0542153">cross3</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:a8416e098f4a05f7576993933e0542153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f98663efdef5673f69373796061116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad9f98663efdef5673f69373796061116">unitOrthogonal</a> (void) const </td></tr>
<tr class="separator:ad9f98663efdef5673f69373796061116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d90b12b21e1aaa2a9de9b0e45e6b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#gac3d90b12b21e1aaa2a9de9b0e45e6b7c">eulerAngles</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> a0, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> a1, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> a2) const </td></tr>
<tr class="separator:gac3d90b12b21e1aaa2a9de9b0e45e6b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788456a7bea3452aae2791c47c96538d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">HNormalizedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a788456a7bea3452aae2791c47c96538d">hnormalized</a> () const </td></tr>
<tr class="separator:a788456a7bea3452aae2791c47c96538d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4bac7dffe2685ab93734fb776e817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aebf4bac7dffe2685ab93734fb776e817">makeHouseholderInPlace</a> (Scalar &amp;tau, RealScalar &amp;beta)</td></tr>
<tr class="separator:aebf4bac7dffe2685ab93734fb776e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae79b7749f8085b3170e64d3750b237c"><td class="memTemplParams" colspan="2">template&lt;typename EssentialPart &gt; </td></tr>
<tr class="memitem:aae79b7749f8085b3170e64d3750b237c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aae79b7749f8085b3170e64d3750b237c">makeHouseholder</a> (EssentialPart &amp;essential, Scalar &amp;tau, RealScalar &amp;beta) const </td></tr>
<tr class="separator:aae79b7749f8085b3170e64d3750b237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2c8059ef3f04cfa0c73b4c012db855"><td class="memTemplParams" colspan="2">template&lt;typename EssentialPart &gt; </td></tr>
<tr class="memitem:a8f2c8059ef3f04cfa0c73b4c012db855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a8f2c8059ef3f04cfa0c73b4c012db855">applyHouseholderOnTheLeft</a> (const EssentialPart &amp;essential, const Scalar &amp;tau, Scalar *workspace)</td></tr>
<tr class="separator:a8f2c8059ef3f04cfa0c73b4c012db855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e52262b41fa40e194dda245e0f9675"><td class="memTemplParams" colspan="2">template&lt;typename EssentialPart &gt; </td></tr>
<tr class="memitem:ab3e52262b41fa40e194dda245e0f9675"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ab3e52262b41fa40e194dda245e0f9675">applyHouseholderOnTheRight</a> (const EssentialPart &amp;essential, const Scalar &amp;tau, Scalar *workspace)</td></tr>
<tr class="separator:ab3e52262b41fa40e194dda245e0f9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae669131f6e18f7e8f06fae271754f435"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar &gt; </td></tr>
<tr class="memitem:ae669131f6e18f7e8f06fae271754f435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae669131f6e18f7e8f06fae271754f435">applyOnTheLeft</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> p, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> q, const <a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;j)</td></tr>
<tr class="separator:ae669131f6e18f7e8f06fae271754f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07f741c86219601664433777827bf1c"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar &gt; </td></tr>
<tr class="memitem:aa07f741c86219601664433777827bf1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#aa07f741c86219601664433777827bf1c">applyOnTheRight</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> p, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> q, const <a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;j)</td></tr>
<tr class="separator:aa07f741c86219601664433777827bf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31953af786d8bef8335503ad31c0f75"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad31953af786d8bef8335503ad31c0f75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;<br class="typebreak"/>
::<a class="el" href="class_eigen_1_1_cwise_unary_op.html">ScalarMultipleReturnType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad31953af786d8bef8335503ad31c0f75">operator*</a> (const UniformScaling&lt; Scalar &gt; &amp;s) const </td></tr>
<tr class="separator:ad31953af786d8bef8335503ad31c0f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_eigen_1_1_dense_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_eigen_1_1_dense_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_eigen_1_1_dense_base.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:af418046dfe3ce99268652fcdbcd3c0c8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#af418046dfe3ce99268652fcdbcd3c0c8">nonZeros</a> () const </td></tr>
<tr class="separator:af418046dfe3ce99268652fcdbcd3c0c8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf2a5853489c10c438cbb47ea57547 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aaabf2a5853489c10c438cbb47ea57547">outerSize</a> () const </td></tr>
<tr class="separator:aaabf2a5853489c10c438cbb47ea57547 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3449027a2e236ac52913c13a795a71 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2b3449027a2e236ac52913c13a795a71">innerSize</a> () const </td></tr>
<tr class="separator:a2b3449027a2e236ac52913c13a795a71 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07436094bdc71503b3ebebe6356a00b8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a07436094bdc71503b3ebebe6356a00b8">resize</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:a07436094bdc71503b3ebebe6356a00b8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e2b4887b47b1f2346857d1931efa0f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a25e2b4887b47b1f2346857d1931efa0f">resize</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols)</td></tr>
<tr class="separator:a25e2b4887b47b1f2346857d1931efa0f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeccb45dd8a3bed57bf93d190dcc041 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aceeccb45dd8a3bed57bf93d190dcc041 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aceeccb45dd8a3bed57bf93d190dcc041">operator=</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:aceeccb45dd8a3bed57bf93d190dcc041 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a39b321cbafc30de01eb78ed4e3aa inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a288a39b321cbafc30de01eb78ed4e3aa">operator=</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a> &amp;other)</td></tr>
<tr class="separator:a288a39b321cbafc30de01eb78ed4e3aa inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58915510693d64164e567bd762e1032f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a58915510693d64164e567bd762e1032f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a58915510693d64164e567bd762e1032f">operator=</a> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a58915510693d64164e567bd762e1032f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4dac13e51f92619493a68b1150d489 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:adf4dac13e51f92619493a68b1150d489 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#adf4dac13e51f92619493a68b1150d489">lazyAssign</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:adf4dac13e51f92619493a68b1150d489 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e575eb0ba6cc6bc5f347872abd8509d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_comma_initializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a0e575eb0ba6cc6bc5f347872abd8509d">operator&lt;&lt;</a> (const Scalar &amp;s)</td></tr>
<tr class="separator:a0e575eb0ba6cc6bc5f347872abd8509d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3485f604899be0ad6dbc419dcad8539f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;unsigned int Added, unsigned int Removed&gt; </td></tr>
<tr class="memitem:a3485f604899be0ad6dbc419dcad8539f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_flagged.html">Flagged</a>&lt; Derived, Added, <br class="typebreak"/>
Removed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3485f604899be0ad6dbc419dcad8539f">flagged</a> () const </td></tr>
<tr class="separator:a3485f604899be0ad6dbc419dcad8539f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e34696162b34762b2bf4bd948f90c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a0f0e34696162b34762b2bf4bd948f90c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_comma_initializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a0f0e34696162b34762b2bf4bd948f90c">operator&lt;&lt;</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a0f0e34696162b34762b2bf4bd948f90c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8952c19644a4ac7e41bea45c19b909c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_transpose.html">Eigen::Transpose</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ac8952c19644a4ac7e41bea45c19b909c">transpose</a> ()</td></tr>
<tr class="separator:ac8952c19644a4ac7e41bea45c19b909c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5d71dd1d4b8f216cf143dfb2a1f400 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_transpose.html">ConstTransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aca5d71dd1d4b8f216cf143dfb2a1f400">transpose</a> () const </td></tr>
<tr class="separator:aca5d71dd1d4b8f216cf143dfb2a1f400 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac501bd942994af7a95d95bee7a16ad2a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace</a> ()</td></tr>
<tr class="separator:ac501bd942994af7a95d95bee7a16ad2a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1b1f8b16b73e7e69489d790f5207ec inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vector_block.html">SegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3d1b1f8b16b73e7e69489d790f5207ec">segment</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> start, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:a3d1b1f8b16b73e7e69489d790f5207ec inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284f6f26592e7c680055a60ef7c9ed2a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vector_block.html">DenseBase::ConstSegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a284f6f26592e7c680055a60ef7c9ed2a">segment</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> start, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size) const </td></tr>
<tr class="separator:a284f6f26592e7c680055a60ef7c9ed2a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7a73b7ce3c202d31ee5d028808da8a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vector_block.html">SegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a8b7a73b7ce3c202d31ee5d028808da8a">head</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:a8b7a73b7ce3c202d31ee5d028808da8a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc47122cc578d666552fac47a383c415 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vector_block.html">DenseBase::ConstSegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#adc47122cc578d666552fac47a383c415">head</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size) const </td></tr>
<tr class="separator:adc47122cc578d666552fac47a383c415 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a28aa08d015272afcbcd63172a5f80f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vector_block.html">SegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a5a28aa08d015272afcbcd63172a5f80f">tail</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:a5a28aa08d015272afcbcd63172a5f80f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3259d848a4c706d259617dcfb383ef5a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vector_block.html">DenseBase::ConstSegmentReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3259d848a4c706d259617dcfb383ef5a">tail</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size) const </td></tr>
<tr class="separator:a3259d848a4c706d259617dcfb383ef5a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2469b9f2f4bae8cc45932edd1303320a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int Size&gt; </td></tr>
<tr class="memitem:a2469b9f2f4bae8cc45932edd1303320a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; Size &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2469b9f2f4bae8cc45932edd1303320a">head</a> ()</td></tr>
<tr class="separator:a2469b9f2f4bae8cc45932edd1303320a inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d34e5531d30945b92fda79846e9f78 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int Size&gt; </td></tr>
<tr class="memitem:a70d34e5531d30945b92fda79846e9f78 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType<br class="typebreak"/>
&lt; Size &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a70d34e5531d30945b92fda79846e9f78">head</a> () const </td></tr>
<tr class="separator:a70d34e5531d30945b92fda79846e9f78 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27b98b80664f8158b955ea392ff4309 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int Size&gt; </td></tr>
<tr class="memitem:ad27b98b80664f8158b955ea392ff4309 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; Size &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad27b98b80664f8158b955ea392ff4309">tail</a> ()</td></tr>
<tr class="separator:ad27b98b80664f8158b955ea392ff4309 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f8f7eda79fef424a0676264f22d1a7 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int Size&gt; </td></tr>
<tr class="memitem:a69f8f7eda79fef424a0676264f22d1a7 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType<br class="typebreak"/>
&lt; Size &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a69f8f7eda79fef424a0676264f22d1a7">tail</a> () const </td></tr>
<tr class="separator:a69f8f7eda79fef424a0676264f22d1a7 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abfbb1dcfbbd0fab87da9d927a33671 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int Size&gt; </td></tr>
<tr class="memitem:a3abfbb1dcfbbd0fab87da9d927a33671 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; Size &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3abfbb1dcfbbd0fab87da9d927a33671">segment</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> start)</td></tr>
<tr class="separator:a3abfbb1dcfbbd0fab87da9d927a33671 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab8ee7def653a2ad8ffd1e9d1ca3160 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int Size&gt; </td></tr>
<tr class="memitem:abab8ee7def653a2ad8ffd1e9d1ca3160 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType<br class="typebreak"/>
&lt; Size &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#abab8ee7def653a2ad8ffd1e9d1ca3160">segment</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> start) const </td></tr>
<tr class="separator:abab8ee7def653a2ad8ffd1e9d1ca3160 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4886d2dd3f6e63bc636f48914d035f9b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a4886d2dd3f6e63bc636f48914d035f9b">fill</a> (const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>)</td></tr>
<tr class="separator:a4886d2dd3f6e63bc636f48914d035f9b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0159dd86325b3c2bc40e3df0e1da3 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a5bd0159dd86325b3c2bc40e3df0e1da3">setConstant</a> (const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>)</td></tr>
<tr class="separator:a5bd0159dd86325b3c2bc40e3df0e1da3 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf8f19c918c70092973704970a03239 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aeaf8f19c918c70092973704970a03239">setLinSpaced</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="separator:aeaf8f19c918c70092973704970a03239 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f13f49db756e456d4b0f2aeb08bb9 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aa01f13f49db756e456d4b0f2aeb08bb9">setLinSpaced</a> (const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="separator:aa01f13f49db756e456d4b0f2aeb08bb9 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dda7dd6ba5960b3b77a91211dbee13 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a00dda7dd6ba5960b3b77a91211dbee13">setZero</a> ()</td></tr>
<tr class="separator:a00dda7dd6ba5960b3b77a91211dbee13 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be6f81b837960fc7936bcc2c45b9363 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a9be6f81b837960fc7936bcc2c45b9363">setOnes</a> ()</td></tr>
<tr class="separator:a9be6f81b837960fc7936bcc2c45b9363 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476e5852129ba32beaa1a8a3d7ee0db inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ac476e5852129ba32beaa1a8a3d7ee0db">setRandom</a> ()</td></tr>
<tr class="separator:ac476e5852129ba32beaa1a8a3d7ee0db inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b0e7d2caafcc08f1874c8cb589865f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a64b0e7d2caafcc08f1874c8cb589865f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a64b0e7d2caafcc08f1874c8cb589865f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c53b77373bab2596ec360b9478e939e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a6c53b77373bab2596ec360b9478e939e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a6c53b77373bab2596ec360b9478e939e">isMuchSmallerThan</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a6c53b77373bab2596ec360b9478e939e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d24f1ed4c0083a551cdc3205f3dfbe2 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a9d24f1ed4c0083a551cdc3205f3dfbe2">isApproxToConstant</a> (const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>, RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a9d24f1ed4c0083a551cdc3205f3dfbe2 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c73c6e99a0792369cafed194a2c2be inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a48c73c6e99a0792369cafed194a2c2be">isConstant</a> (const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>, RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a48c73c6e99a0792369cafed194a2c2be inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278d8e7ba04f0d98326799d1f68182cf inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a278d8e7ba04f0d98326799d1f68182cf">isZero</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a278d8e7ba04f0d98326799d1f68182cf inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0b467e309c249fbbd47aaa059df98c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a0c0b467e309c249fbbd47aaa059df98c">isOnes</a> (RealScalar prec=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a0c0b467e309c249fbbd47aaa059df98c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba527898e8a9c34b5773bc3611b36d1 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE EvalReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aaba527898e8a9c34b5773bc3611b36d1">eval</a> () const </td></tr>
<tr class="separator:aaba527898e8a9c34b5773bc3611b36d1 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207e87a74a6f4a7fcd7dc01f2e457ad5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a207e87a74a6f4a7fcd7dc01f2e457ad5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a207e87a74a6f4a7fcd7dc01f2e457ad5">swap</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, int=OtherDerived::ThisConstantIsPrivateInPlainObjectBase)</td></tr>
<tr class="separator:a207e87a74a6f4a7fcd7dc01f2e457ad5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e25adc6da9cd1d79f4c5bd7c1819cb inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a44e25adc6da9cd1d79f4c5bd7c1819cb inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a44e25adc6da9cd1d79f4c5bd7c1819cb">swap</a> (<a class="el" href="class_eigen_1_1_plain_object_base.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a44e25adc6da9cd1d79f4c5bd7c1819cb inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268b6a79f88c40e07f3cb6f0bb7efdab inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_nest_by_value.html">NestByValue</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a268b6a79f88c40e07f3cb6f0bb7efdab">nestByValue</a> () const </td></tr>
<tr class="separator:a268b6a79f88c40e07f3cb6f0bb7efdab inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae893580d10226bcf2a4ccd8fa653e6c8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ae893580d10226bcf2a4ccd8fa653e6c8">sum</a> () const </td></tr>
<tr class="separator:ae893580d10226bcf2a4ccd8fa653e6c8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88eceab67aa14d6d9cb026f3aed2052 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#af88eceab67aa14d6d9cb026f3aed2052">mean</a> () const </td></tr>
<tr class="separator:af88eceab67aa14d6d9cb026f3aed2052 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5fed3fba0d308b4daf0bc826c18f22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a8d5fed3fba0d308b4daf0bc826c18f22">prod</a> () const </td></tr>
<tr class="separator:a8d5fed3fba0d308b4daf0bc826c18f22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0b782ad0b75f6a098df8c2967d1c4c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3b0b782ad0b75f6a098df8c2967d1c4c">minCoeff</a> () const </td></tr>
<tr class="separator:a3b0b782ad0b75f6a098df8c2967d1c4c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4d9377f7eb440180ea1cf8b64c0e3 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a9bd4d9377f7eb440180ea1cf8b64c0e3">maxCoeff</a> () const </td></tr>
<tr class="separator:a9bd4d9377f7eb440180ea1cf8b64c0e3 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7489c619ae27bbe8386a4b8fd7f559f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:ac7489c619ae27bbe8386a4b8fd7f559f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ac7489c619ae27bbe8386a4b8fd7f559f">minCoeff</a> (IndexType *<a class="el" href="class_eigen_1_1_dense_base.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a>, IndexType *<a class="el" href="class_eigen_1_1_dense_base.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col</a>) const </td></tr>
<tr class="separator:ac7489c619ae27bbe8386a4b8fd7f559f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4812a223f7d1b6a287ef0280ebe7b2d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:ac4812a223f7d1b6a287ef0280ebe7b2d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ac4812a223f7d1b6a287ef0280ebe7b2d">maxCoeff</a> (IndexType *<a class="el" href="class_eigen_1_1_dense_base.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a>, IndexType *<a class="el" href="class_eigen_1_1_dense_base.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col</a>) const </td></tr>
<tr class="separator:ac4812a223f7d1b6a287ef0280ebe7b2d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d064b0b324fa36566aa7d52ed338ea1 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a5d064b0b324fa36566aa7d52ed338ea1 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a5d064b0b324fa36566aa7d52ed338ea1">minCoeff</a> (IndexType *index) const </td></tr>
<tr class="separator:a5d064b0b324fa36566aa7d52ed338ea1 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998a8d121cfa2d2aa1da17238658715e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a998a8d121cfa2d2aa1da17238658715e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a998a8d121cfa2d2aa1da17238658715e">maxCoeff</a> (IndexType *index) const </td></tr>
<tr class="separator:a998a8d121cfa2d2aa1da17238658715e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d024ce3e0911add9dfa9ff1c93264e0 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a8d024ce3e0911add9dfa9ff1c93264e0 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a8d024ce3e0911add9dfa9ff1c93264e0">visit</a> (Visitor &amp;func) const </td></tr>
<tr class="separator:a8d024ce3e0911add9dfa9ff1c93264e0 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad481d9f95d57c9194f6f79f7555e49e8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_with_format.html">WithFormat</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad481d9f95d57c9194f6f79f7555e49e8">format</a> (const <a class="el" href="struct_eigen_1_1_i_o_format.html">IOFormat</a> &amp;fmt) const </td></tr>
<tr class="separator:ad481d9f95d57c9194f6f79f7555e49e8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d0388b9daeb8a3584dadd950116f5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a> () const </td></tr>
<tr class="separator:a584d0388b9daeb8a3584dadd950116f5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca44e0a630cf9ed364948f4047a0026 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#abca44e0a630cf9ed364948f4047a0026">all</a> (void) const </td></tr>
<tr class="separator:abca44e0a630cf9ed364948f4047a0026 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bec0b18a9fb9b6622717df8a887fa92 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a0bec0b18a9fb9b6622717df8a887fa92">any</a> (void) const </td></tr>
<tr class="separator:a0bec0b18a9fb9b6622717df8a887fa92 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ceeb4f3b59725dddbe80c10cd3ec53 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a04ceeb4f3b59725dddbe80c10cd3ec53">count</a> () const </td></tr>
<tr class="separator:a04ceeb4f3b59725dddbe80c10cd3ec53 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2253838b098ceda476c24987c900ca3d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vectorwise_op.html">ConstRowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2253838b098ceda476c24987c900ca3d">rowwise</a> () const </td></tr>
<tr class="separator:a2253838b098ceda476c24987c900ca3d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa3a3156ca0e0722bf78638e1c7f28 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vectorwise_op.html">RowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a6daa3a3156ca0e0722bf78638e1c7f28">rowwise</a> ()</td></tr>
<tr class="separator:a6daa3a3156ca0e0722bf78638e1c7f28 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace61394f264589204453124bd4bbad0d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vectorwise_op.html">ConstColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ace61394f264589204453124bd4bbad0d">colwise</a> () const </td></tr>
<tr class="separator:ace61394f264589204453124bd4bbad0d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0e1b6067ec1de6cb8799da55aa7d30 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_vectorwise_op.html">ColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a1c0e1b6067ec1de6cb8799da55aa7d30">colwise</a> ()</td></tr>
<tr class="separator:a1c0e1b6067ec1de6cb8799da55aa7d30 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec49d21e1bf32797180e5d21a489f98 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived , typename ElseDerived &gt; </td></tr>
<tr class="memitem:aaec49d21e1bf32797180e5d21a489f98 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_select.html">Select</a>&lt; Derived, <br class="typebreak"/>
ThenDerived, ElseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aaec49d21e1bf32797180e5d21a489f98">select</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const </td></tr>
<tr class="separator:aaec49d21e1bf32797180e5d21a489f98 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5880504083cb36beae44e9b6777a5508 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived &gt; </td></tr>
<tr class="memitem:a5880504083cb36beae44e9b6777a5508 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_select.html">Select</a>&lt; Derived, <br class="typebreak"/>
ThenDerived, typename <br class="typebreak"/>
ThenDerived::ConstantReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a5880504083cb36beae44e9b6777a5508">select</a> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, typename ThenDerived::Scalar elseScalar) const </td></tr>
<tr class="separator:a5880504083cb36beae44e9b6777a5508 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99754cfd894e669309c5e0c51657dde inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename ElseDerived &gt; </td></tr>
<tr class="memitem:ac99754cfd894e669309c5e0c51657dde inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_select.html">Select</a>&lt; Derived, <br class="typebreak"/>
typename <br class="typebreak"/>
ElseDerived::ConstantReturnType, <br class="typebreak"/>
ElseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ac99754cfd894e669309c5e0c51657dde">select</a> (typename ElseDerived::Scalar thenScalar, const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const </td></tr>
<tr class="separator:ac99754cfd894e669309c5e0c51657dde inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f89ab26ccf66c3a9d0190e10243cb9e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int RowFactor, int ColFactor&gt; </td></tr>
<tr class="memitem:a4f89ab26ccf66c3a9d0190e10243cb9e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_replicate.html">Replicate</a>&lt; Derived, <br class="typebreak"/>
RowFactor, ColFactor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a4f89ab26ccf66c3a9d0190e10243cb9e">replicate</a> () const </td></tr>
<tr class="separator:a4f89ab26ccf66c3a9d0190e10243cb9e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e20380d79d190e883aeaa1092ed894b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_replicate.html">Replicate</a>&lt; Derived, <br class="typebreak"/>
Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a6e20380d79d190e883aeaa1092ed894b">replicate</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rowFacor, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> colFactor) const </td></tr>
<tr class="separator:a6e20380d79d190e883aeaa1092ed894b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea394036d8b096abf322469c80198f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a38ea394036d8b096abf322469c80198f">reverse</a> ()</td></tr>
<tr class="separator:a38ea394036d8b096abf322469c80198f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90d77ba141b07e0db264f135b197acc inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad90d77ba141b07e0db264f135b197acc">reverse</a> () const </td></tr>
<tr class="separator:ad90d77ba141b07e0db264f135b197acc inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8045155ea45f7961fc2a5170e1d921 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#adb8045155ea45f7961fc2a5170e1d921">reverseInPlace</a> ()</td></tr>
<tr class="separator:adb8045155ea45f7961fc2a5170e1d921 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a2435878fd8d98602e60b63cf3909c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a78a2435878fd8d98602e60b63cf3909c">block</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> blockRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> blockCols)</td></tr>
<tr class="separator:a78a2435878fd8d98602e60b63cf3909c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80af188f8cfe47ebd0acbdb4b82bab4 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ab80af188f8cfe47ebd0acbdb4b82bab4">block</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> blockRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> blockCols) const </td></tr>
<tr class="separator:ab80af188f8cfe47ebd0acbdb4b82bab4 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c342d36e973785dfeb556419d12e30c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2c342d36e973785dfeb556419d12e30c">topRightCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols)</td></tr>
<tr class="separator:a2c342d36e973785dfeb556419d12e30c inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af823531bfed41c6149e7f769809ba071 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#af823531bfed41c6149e7f769809ba071">topRightCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols) const </td></tr>
<tr class="separator:af823531bfed41c6149e7f769809ba071 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2165468abe506f72621aa29d57739047 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a2165468abe506f72621aa29d57739047 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2165468abe506f72621aa29d57739047">topRightCorner</a> ()</td></tr>
<tr class="separator:a2165468abe506f72621aa29d57739047 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb049b869b7d38061d62b2c9e2a89f7e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:afb049b869b7d38061d62b2c9e2a89f7e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#afb049b869b7d38061d62b2c9e2a89f7e">topRightCorner</a> () const </td></tr>
<tr class="separator:afb049b869b7d38061d62b2c9e2a89f7e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eb0aa506ffc92969049b23cca7ce60 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a12eb0aa506ffc92969049b23cca7ce60">topLeftCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols)</td></tr>
<tr class="separator:a12eb0aa506ffc92969049b23cca7ce60 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fd0e76aabd7d6c800ec8801f2074bd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a94fd0e76aabd7d6c800ec8801f2074bd">topLeftCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols) const </td></tr>
<tr class="separator:a94fd0e76aabd7d6c800ec8801f2074bd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2103a319121af004364eb2a8681193 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a2d2103a319121af004364eb2a8681193 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2d2103a319121af004364eb2a8681193">topLeftCorner</a> ()</td></tr>
<tr class="separator:a2d2103a319121af004364eb2a8681193 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e2131add766a8c212989297a363a55 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a72e2131add766a8c212989297a363a55 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a72e2131add766a8c212989297a363a55">topLeftCorner</a> () const </td></tr>
<tr class="separator:a72e2131add766a8c212989297a363a55 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e6b24ac56eb1bf0b5cfd2102a10642 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a22e6b24ac56eb1bf0b5cfd2102a10642">bottomRightCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols)</td></tr>
<tr class="separator:a22e6b24ac56eb1bf0b5cfd2102a10642 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7e4255e88f2f65dcd3e8e172d5874 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a08b7e4255e88f2f65dcd3e8e172d5874">bottomRightCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols) const </td></tr>
<tr class="separator:a08b7e4255e88f2f65dcd3e8e172d5874 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a257bc9ce73435048203ceb17dc3a5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:aa2a257bc9ce73435048203ceb17dc3a5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aa2a257bc9ce73435048203ceb17dc3a5">bottomRightCorner</a> ()</td></tr>
<tr class="separator:aa2a257bc9ce73435048203ceb17dc3a5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801a0e6e1c249fa90d2997fffb7bd839 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a801a0e6e1c249fa90d2997fffb7bd839 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a801a0e6e1c249fa90d2997fffb7bd839">bottomRightCorner</a> () const </td></tr>
<tr class="separator:a801a0e6e1c249fa90d2997fffb7bd839 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada832a93d44b4706331440a6b18fa74 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aada832a93d44b4706331440a6b18fa74">bottomLeftCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols)</td></tr>
<tr class="separator:aada832a93d44b4706331440a6b18fa74 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e7b8eaad3f0fc857935ca318caab58 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a26e7b8eaad3f0fc857935ca318caab58">bottomLeftCorner</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cRows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cCols) const </td></tr>
<tr class="separator:a26e7b8eaad3f0fc857935ca318caab58 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a46897649b90e1b5e576acad0b170 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a012a46897649b90e1b5e576acad0b170 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a012a46897649b90e1b5e576acad0b170">bottomLeftCorner</a> ()</td></tr>
<tr class="separator:a012a46897649b90e1b5e576acad0b170 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0471d28a5793dccddfbdc516532f95 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:aab0471d28a5793dccddfbdc516532f95 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aab0471d28a5793dccddfbdc516532f95">bottomLeftCorner</a> () const </td></tr>
<tr class="separator:aab0471d28a5793dccddfbdc516532f95 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb8bf8b8d6d2648f52dadd0e4cba68e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">RowsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aafb8bf8b8d6d2648f52dadd0e4cba68e">topRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n)</td></tr>
<tr class="separator:aafb8bf8b8d6d2648f52dadd0e4cba68e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77615e830d639c2e3ad454f18fe83d6 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstRowsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad77615e830d639c2e3ad454f18fe83d6">topRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n) const </td></tr>
<tr class="separator:ad77615e830d639c2e3ad454f18fe83d6 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a91a94f7e660860a18b626b649bc719 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8a91a94f7e660860a18b626b649bc719 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a8a91a94f7e660860a18b626b649bc719">topRows</a> ()</td></tr>
<tr class="separator:a8a91a94f7e660860a18b626b649bc719 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97756af92c05f01c1c1dd7a2cef3309f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a97756af92c05f01c1c1dd7a2cef3309f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a97756af92c05f01c1c1dd7a2cef3309f">topRows</a> () const </td></tr>
<tr class="separator:a97756af92c05f01c1c1dd7a2cef3309f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36137187863fe127fe88e7388eacabaa inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">RowsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a36137187863fe127fe88e7388eacabaa">bottomRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n)</td></tr>
<tr class="separator:a36137187863fe127fe88e7388eacabaa inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7aab3ea224f0d3deea7896b8164e40 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstRowsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aec7aab3ea224f0d3deea7896b8164e40">bottomRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n) const </td></tr>
<tr class="separator:aec7aab3ea224f0d3deea7896b8164e40 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82261e23125627bafcf7281d9a4ace5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad82261e23125627bafcf7281d9a4ace5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad82261e23125627bafcf7281d9a4ace5">bottomRows</a> ()</td></tr>
<tr class="separator:ad82261e23125627bafcf7281d9a4ace5 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1676a55fa34bb643bc2bbb19d1fac0b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ab1676a55fa34bb643bc2bbb19d1fac0b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ab1676a55fa34bb643bc2bbb19d1fac0b">bottomRows</a> () const </td></tr>
<tr class="separator:ab1676a55fa34bb643bc2bbb19d1fac0b inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a91424516ca392ba785a0485d9dcafd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">RowsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a2a91424516ca392ba785a0485d9dcafd">middleRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> numRows)</td></tr>
<tr class="separator:a2a91424516ca392ba785a0485d9dcafd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc124ddc5a1cadadd98904d80d711756 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstRowsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#afc124ddc5a1cadadd98904d80d711756">middleRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> numRows) const </td></tr>
<tr class="separator:afc124ddc5a1cadadd98904d80d711756 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ce8f522a09abeee3e7c769e9271d22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a98ce8f522a09abeee3e7c769e9271d22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a98ce8f522a09abeee3e7c769e9271d22">middleRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow)</td></tr>
<tr class="separator:a98ce8f522a09abeee3e7c769e9271d22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932a040b309ad4177aee374345e4c1a8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a932a040b309ad4177aee374345e4c1a8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a932a040b309ad4177aee374345e4c1a8">middleRows</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow) const </td></tr>
<tr class="separator:a932a040b309ad4177aee374345e4c1a8 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c4e7a7264c0acde4632d35a9a2635 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ColsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a4c7c4e7a7264c0acde4632d35a9a2635">leftCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n)</td></tr>
<tr class="separator:a4c7c4e7a7264c0acde4632d35a9a2635 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ea68ce5cd8a8cfe6281f9ed9b5a904 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstColsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a21ea68ce5cd8a8cfe6281f9ed9b5a904">leftCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n) const </td></tr>
<tr class="separator:a21ea68ce5cd8a8cfe6281f9ed9b5a904 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa9eed6efbabc5cd16bccfc4b4983a6 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aafa9eed6efbabc5cd16bccfc4b4983a6 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aafa9eed6efbabc5cd16bccfc4b4983a6">leftCols</a> ()</td></tr>
<tr class="separator:aafa9eed6efbabc5cd16bccfc4b4983a6 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb567ba08c237375ae09148dd8cc7d18 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:adb567ba08c237375ae09148dd8cc7d18 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#adb567ba08c237375ae09148dd8cc7d18">leftCols</a> () const </td></tr>
<tr class="separator:adb567ba08c237375ae09148dd8cc7d18 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a43920b4d907a7edba59c26fba7b43d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ColsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a5a43920b4d907a7edba59c26fba7b43d">rightCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n)</td></tr>
<tr class="separator:a5a43920b4d907a7edba59c26fba7b43d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5b7d2734879dc790670f15619a7c72 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstColsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aee5b7d2734879dc790670f15619a7c72">rightCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> n) const </td></tr>
<tr class="separator:aee5b7d2734879dc790670f15619a7c72 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45cd9e0c27f7a3d848f08ded5b55ff9 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ae45cd9e0c27f7a3d848f08ded5b55ff9 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ae45cd9e0c27f7a3d848f08ded5b55ff9">rightCols</a> ()</td></tr>
<tr class="separator:ae45cd9e0c27f7a3d848f08ded5b55ff9 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5e2d21b59a0239f72220a4eae84c1e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a1d5e2d21b59a0239f72220a4eae84c1e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a1d5e2d21b59a0239f72220a4eae84c1e">rightCols</a> () const </td></tr>
<tr class="separator:a1d5e2d21b59a0239f72220a4eae84c1e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f65c4d33b2ac9d32d158181c6b23e2 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ColsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ab4f65c4d33b2ac9d32d158181c6b23e2">middleCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> numCols)</td></tr>
<tr class="separator:ab4f65c4d33b2ac9d32d158181c6b23e2 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b7e3ec0a8a07f0a0022ca6eeb4e22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstColsBlockXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a856b7e3ec0a8a07f0a0022ca6eeb4e22">middleCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> numCols) const </td></tr>
<tr class="separator:a856b7e3ec0a8a07f0a0022ca6eeb4e22 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673cef6e147960fa402411656b9fdb71 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a673cef6e147960fa402411656b9fdb71 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a673cef6e147960fa402411656b9fdb71">middleCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol)</td></tr>
<tr class="separator:a673cef6e147960fa402411656b9fdb71 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb92fccd737a944a7bb8a5857fd16e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a0ccb92fccd737a944a7bb8a5857fd16e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a0ccb92fccd737a944a7bb8a5857fd16e">middleCols</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol) const </td></tr>
<tr class="separator:a0ccb92fccd737a944a7bb8a5857fd16e inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d0061b4d11c5a42b0fde29297343fd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int BlockRows, int BlockCols&gt; </td></tr>
<tr class="memitem:ae5d0061b4d11c5a42b0fde29297343fd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; Derived, BlockRows, <br class="typebreak"/>
BlockCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ae5d0061b4d11c5a42b0fde29297343fd">block</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol)</td></tr>
<tr class="separator:ae5d0061b4d11c5a42b0fde29297343fd inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d88902dd73690ccab852a2f0f46eb24 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;int BlockRows, int BlockCols&gt; </td></tr>
<tr class="memitem:a7d88902dd73690ccab852a2f0f46eb24 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
BlockRows, BlockCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a7d88902dd73690ccab852a2f0f46eb24">block</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startRow, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> startCol) const </td></tr>
<tr class="separator:a7d88902dd73690ccab852a2f0f46eb24 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f3b8aeaf37cb1decc9413ffceafa0f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ColXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> i)</td></tr>
<tr class="separator:a27f3b8aeaf37cb1decc9413ffceafa0f inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f8768fe4214a670f742144e9624193 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstColXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a32f8768fe4214a670f742144e9624193">col</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> i) const </td></tr>
<tr class="separator:a32f8768fe4214a670f742144e9624193 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bc4a61cdf4ad219db0e70de12c2ae2 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">RowXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> i)</td></tr>
<tr class="separator:a09bc4a61cdf4ad219db0e70de12c2ae2 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ca1a9266fcd2f0af61b64cadc9b037 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_block.html">ConstRowXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a01ca1a9266fcd2f0af61b64cadc9b037">row</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> i) const </td></tr>
<tr class="separator:a01ca1a9266fcd2f0af61b64cadc9b037 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3864272684256a911e175822d875c44d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3864272684256a911e175822d875c44d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3864272684256a911e175822d875c44d">isMuchSmallerThan</a> (const typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Scalar &gt;::Real &amp;other, RealScalar prec) const </td></tr>
<tr class="separator:a3864272684256a911e175822d875c44d inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa53f535a5b4599351be93479900bb95 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:afa53f535a5b4599351be93479900bb95 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE <br class="typebreak"/>
internal::result_of&lt; Func(typename <br class="typebreak"/>
internal::traits&lt; Derived &gt;<br class="typebreak"/>
::Scalar)&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#afa53f535a5b4599351be93479900bb95">redux</a> (const Func &amp;func) const </td></tr>
<tr class="separator:afa53f535a5b4599351be93479900bb95 inherit pub_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a040dec5c5a3525b649fb6e3a996bde6a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">IdentityReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a040dec5c5a3525b649fb6e3a996bde6a">Identity</a> ()</td></tr>
<tr class="separator:a040dec5c5a3525b649fb6e3a996bde6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64da0ae7a79293f9934ce5084654e77"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">IdentityReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#af64da0ae7a79293f9934ce5084654e77">Identity</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols)</td></tr>
<tr class="separator:af64da0ae7a79293f9934ce5084654e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b888173c31bf111bff950ee7a7ac6"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ad28b888173c31bf111bff950ee7a7ac6">Unit</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> i)</td></tr>
<tr class="separator:ad28b888173c31bf111bff950ee7a7ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70cc18783815a995aae33c0f230ad48"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ab70cc18783815a995aae33c0f230ad48">Unit</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> i)</td></tr>
<tr class="separator:ab70cc18783815a995aae33c0f230ad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3738ca476bb8da822a88fc99e2278e45"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a3738ca476bb8da822a88fc99e2278e45">UnitX</a> ()</td></tr>
<tr class="separator:a3738ca476bb8da822a88fc99e2278e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d96862654ea88a1cea066dbb894efc"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">UnitY</a> ()</td></tr>
<tr class="separator:ae9d96862654ea88a1cea066dbb894efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb31f6df86be131b52451dd2e979bc9"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">UnitZ</a> ()</td></tr>
<tr class="separator:a8eb31f6df86be131b52451dd2e979bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e38a13a3c774415076efb6a4402113e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">UnitW</a> ()</td></tr>
<tr class="separator:a2e38a13a3c774415076efb6a4402113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_eigen_1_1_dense_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_eigen_1_1_dense_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_eigen_1_1_dense_base.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:ab0ae1bfa72faedcaf53af81ca76c446b inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ab0ae1bfa72faedcaf53af81ca76c446b">Constant</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols, const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>)</td></tr>
<tr class="separator:ab0ae1bfa72faedcaf53af81ca76c446b inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b2496533c42f1c2f1ff78bdea7cc9 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a396b2496533c42f1c2f1ff78bdea7cc9">Constant</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size, const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>)</td></tr>
<tr class="separator:a396b2496533c42f1c2f1ff78bdea7cc9 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117f486ba2bcc011d5056715fa71b7e6 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a117f486ba2bcc011d5056715fa71b7e6">Constant</a> (const Scalar &amp;<a class="el" href="class_eigen_1_1_dense_base.html#a584d0388b9daeb8a3584dadd950116f5">value</a>)</td></tr>
<tr class="separator:a117f486ba2bcc011d5056715fa71b7e6 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211816063f0e42a94226174a69b77aac inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_nullary_op.html">SequentialLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a211816063f0e42a94226174a69b77aac">LinSpaced</a> (Sequential_t, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="separator:a211816063f0e42a94226174a69b77aac inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af650d990aeb5ef39582cfff935adeff1 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_nullary_op.html">RandomAccessLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#af650d990aeb5ef39582cfff935adeff1">LinSpaced</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="separator:af650d990aeb5ef39582cfff935adeff1 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53089bcadab5b52dfc6e21c3a9987ed inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_nullary_op.html">SequentialLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ae53089bcadab5b52dfc6e21c3a9987ed">LinSpaced</a> (Sequential_t, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="separator:ae53089bcadab5b52dfc6e21c3a9987ed inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca927bc3f8605805f8bb4f1a5eb4754 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="class_eigen_1_1_cwise_nullary_op.html">RandomAccessLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#adca927bc3f8605805f8bb4f1a5eb4754">LinSpaced</a> (const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="separator:adca927bc3f8605805f8bb4f1a5eb4754 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498e05f3e1b5c9327a53fd65a1f4b20b inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a498e05f3e1b5c9327a53fd65a1f4b20b inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a498e05f3e1b5c9327a53fd65a1f4b20b">NullaryExpr</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a498e05f3e1b5c9327a53fd65a1f4b20b inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a05548be847907469b72fab56f88a0 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a70a05548be847907469b72fab56f88a0 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a70a05548be847907469b72fab56f88a0">NullaryExpr</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a70a05548be847907469b72fab56f88a0 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeea4268673be666b629c62eed00051 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a6eeea4268673be666b629c62eed00051 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a6eeea4268673be666b629c62eed00051">NullaryExpr</a> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a6eeea4268673be666b629c62eed00051 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905cb30de691190f85ad1abb97f65100 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a905cb30de691190f85ad1abb97f65100">Zero</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols)</td></tr>
<tr class="separator:a905cb30de691190f85ad1abb97f65100 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125c4b37508ecfe65c137810f195e42f inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a125c4b37508ecfe65c137810f195e42f">Zero</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:a125c4b37508ecfe65c137810f195e42f inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aaacdd651521e9797e84ce345f2831 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#ad2aaacdd651521e9797e84ce345f2831">Zero</a> ()</td></tr>
<tr class="separator:ad2aaacdd651521e9797e84ce345f2831 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804d0651dfbe4c5a2e4b236cc487151 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a8804d0651dfbe4c5a2e4b236cc487151">Ones</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols)</td></tr>
<tr class="separator:a8804d0651dfbe4c5a2e4b236cc487151 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac062bc3ddf016ba1ed23d1beb3a0bca inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aac062bc3ddf016ba1ed23d1beb3a0bca">Ones</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:aac062bc3ddf016ba1ed23d1beb3a0bca inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864a3e957343b818effdaeaeb08729a0 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a864a3e957343b818effdaeaeb08729a0">Ones</a> ()</td></tr>
<tr class="separator:a864a3e957343b818effdaeaeb08729a0 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888bc73e7504b7c619a4224994e24c3c inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; Scalar &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a888bc73e7504b7c619a4224994e24c3c">Random</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> rows, <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> cols)</td></tr>
<tr class="separator:a888bc73e7504b7c619a4224994e24c3c inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a4fcd5377a2a99cc6215a0fcce9a2 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; Scalar &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a8c3a4fcd5377a2a99cc6215a0fcce9a2">Random</a> (<a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> size)</td></tr>
<tr class="separator:a8c3a4fcd5377a2a99cc6215a0fcce9a2 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167eb9a0e8b75f678363d6ff4d9f2d8 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; Scalar &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#af167eb9a0e8b75f678363d6ff4d9f2d8">Random</a> ()</td></tr>
<tr class="separator:af167eb9a0e8b75f678363d6ff4d9f2d8 inherit pub_static_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_eigen_1_1_dense_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_eigen_1_1_dense_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_eigen_1_1_dense_base.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:aa284042d0e1b0ad9b6a00db7fd2d9f7f inherit pro_methods_class_eigen_1_1_dense_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#aa284042d0e1b0ad9b6a00db7fd2d9f7f">DenseBase</a> ()</td></tr>
<tr class="separator:aa284042d0e1b0ad9b6a00db7fd2d9f7f inherit pro_methods_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_class_eigen_1_1_dense_base"><td colspan="2" onclick="javascript:toggleInherit('related_class_eigen_1_1_dense_base')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="class_eigen_1_1_dense_base.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a inherit related_class_eigen_1_1_dense_base"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a inherit related_class_eigen_1_1_dense_base"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html#a3806d3f42de165878dace160e6aba40a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; Derived &gt; &amp;m)</td></tr>
<tr class="separator:a3806d3f42de165878dace160e6aba40a inherit related_class_eigen_1_1_dense_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Derived&gt;<br/>
class Eigen::MatrixBase&lt; Derived &gt;</h3>

<p>Base class for all dense matrices, vectors, and expressions. </p>
<p>This class is the base that is inherited by all matrix, vector, and related expression types. Most of the Eigen API is contained in this class, and its base classes. Other important classes for the Eigen API are <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>, and <a class="el" href="class_eigen_1_1_vectorwise_op.html" title="Pseudo expression providing partial reduction operations.">VectorwiseOp</a>.</p>
<p>Note that some methods are defined in other modules such as the LU_Module LU module for all functions related to matrix inversions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>is the derived type, e.g. a matrix type, or an expression, etc.</td></tr>
  </table>
  </dd>
</dl>
<p>When writing a function taking Eigen objects as argument, if you want your function to take as argument any matrix, vector, or expression, just let it take a <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> argument. As an example, here is a function printFirstRow which, given a matrix, vector, or expression <em>x</em>, prints the first row of <em>x</em>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keywordtype">void</span> printFirstRow(<span class="keyword">const</span> <a class="code" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions.">Eigen::MatrixBase&lt;Derived&gt;</a>&amp; x)</div>
<div class="line">{</div>
<div class="line">  cout &lt;&lt; x.<a class="code" href="class_eigen_1_1_dense_base.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a>(0) &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This class can be extended with the help of the plugin mechanism described on the page TopicCustomizingEigen by defining the preprocessor symbol <code>EIGEN_MATRIXBASE_PLUGIN</code>.</p>
<dl class="section see"><dt>See Also</dt><dd>TopicClassHierarchy </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a02545f8c3f4551e949c1ea0517a0d41c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt;typename internal::traits&lt;Derived&gt;::Scalar, internal::traits&lt;Derived&gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, internal::traits&lt;Derived&gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, AutoAlign | (internal::traits&lt;Derived&gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>&amp;RowMajorBit ? RowMajor : ColMajor), internal::traits&lt;Derived&gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, internal::traits&lt;Derived&gt;::<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfacc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The plain matrix type corresponding to this expression. </p>
<p>This is not necessarily exactly the return type of <a class="el" href="class_eigen_1_1_dense_base.html#aaba527898e8a9c34b5773bc3611b36d1">eval()</a>. In the case of plain matrices, the return type of <a class="el" href="class_eigen_1_1_dense_base.html#aaba527898e8a9c34b5773bc3611b36d1">eval()</a> is a const reference to a matrix, not a matrix! It is however guaranteed that the return type of <a class="el" href="class_eigen_1_1_dense_base.html#aaba527898e8a9c34b5773bc3611b36d1">eval()</a> is either PlainObject or const PlainObject&amp;. </p>

</div>
</div>
<a class="anchor" id="a3cf75a9110a1a28c493e124c8a7fcade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt;Scalar,EIGEN_SIZE_MAX(<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>,<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>), EIGEN_SIZE_MAX(<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>,<a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>)&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a3cf75a9110a1a28c493e124c8a7fcade">SquareMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of the equivalent square matrix </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3ab76dee1a5bf179ad4dcaa437179851"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_cwise_unary_op.html">AdjointReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::adjoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the adjoint (i.e. conjugate transpose) of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its own adjoint, do <b>NOT</b> do this: <div class="fragment"><div class="line">m = m.adjoint(); <span class="comment">// bug!!! caused by aliasing effect</span></div>
</div><!-- fragment --> Instead, use the <a class="el" href="class_eigen_1_1_matrix_base.html#a51c5982c1f64e45a939515b701fa6f4a" title="This is the &quot;in place&quot; version of adjoint(): it replaces *this by its own transpose.">adjointInPlace()</a> method: <div class="fragment"><div class="line">m.adjointInPlace();</div>
</div><!-- fragment --> which gives Eigen good opportunities for optimization, or alternatively you can also do: <div class="fragment"><div class="line">m = m.adjoint().eval();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a51c5982c1f64e45a939515b701fa6f4a" title="This is the &quot;in place&quot; version of adjoint(): it replaces *this by its own transpose.">adjointInPlace()</a>, <a class="el" href="class_eigen_1_1_dense_base.html#ac8952c19644a4ac7e41bea45c19b909c">transpose()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae53e8680069efaf279a7b822e068d6d4">conjugate()</a>, class <a class="el" href="class_eigen_1_1_transpose.html" title="Expression of the transpose of a matrix.">Transpose</a>, class internal::scalar_conjugate_op </dd></dl>

</div>
</div>
<a class="anchor" id="a51c5982c1f64e45a939515b701fa6f4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::adjointInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the "in place" version of <a class="el" href="class_eigen_1_1_matrix_base.html#a3ab76dee1a5bf179ad4dcaa437179851">adjoint()</a>: it replaces <code>*this</code> by its own transpose. </p>
<p>Thus, doing </p>
<div class="fragment"><div class="line">m.adjointInPlace();</div>
</div><!-- fragment --><p> has the same effect on m as doing </p>
<div class="fragment"><div class="line">m = m.adjoint().eval();</div>
</div><!-- fragment --><p> and is faster and also safer because in the latter line of code, forgetting the <a class="el" href="class_eigen_1_1_dense_base.html#aaba527898e8a9c34b5773bc3611b36d1">eval()</a> results in a bug caused by aliasing.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own adjoint. If you just need the adjoint of a matrix, use <a class="el" href="class_eigen_1_1_matrix_base.html#a3ab76dee1a5bf179ad4dcaa437179851">adjoint()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_dense_base.html#ac8952c19644a4ac7e41bea45c19b909c">transpose()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a3ab76dee1a5bf179ad4dcaa437179851">adjoint()</a>, <a class="el" href="class_eigen_1_1_dense_base.html#ac501bd942994af7a95d95bee7a16ad2a" title="This is the &quot;in place&quot; version of transpose(): it replaces *this by its own transpose.">transposeInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2c8059ef3f04cfa0c73b4c012db855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename EssentialPart &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyHouseholderOnTheLeft </td>
          <td>(</td>
          <td class="paramtype">const EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the elementary reflector H given by <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_139.png"/> with <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_140.png"/> from the left to a vector or matrix. </p>
<p>On input: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">workspace</td><td>a pointer to working space with at least this-&gt;cols() * essential.size() entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aae79b7749f8085b3170e64d3750b237c" title="Computes the elementary reflector H such that:  where the transformation H is:  and the vector v is: ...">MatrixBase::makeHouseholder()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#aebf4bac7dffe2685ab93734fb776e817" title="Computes the elementary reflector H such that:  where the transformation H is:  and the vector v is: ...">MatrixBase::makeHouseholderInPlace()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab3e52262b41fa40e194dda245e0f9675" title="Apply the elementary reflector H given by  with  from the right to a vector or matrix.">MatrixBase::applyHouseholderOnTheRight()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab3e52262b41fa40e194dda245e0f9675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename EssentialPart &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyHouseholderOnTheRight </td>
          <td>(</td>
          <td class="paramtype">const EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar *&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the elementary reflector H given by <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_139.png"/> with <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_140.png"/> from the right to a vector or matrix. </p>
<p>On input: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">workspace</td><td>a pointer to working space with at least this-&gt;cols() * essential.size() entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aae79b7749f8085b3170e64d3750b237c" title="Computes the elementary reflector H such that:  where the transformation H is:  and the vector v is: ...">MatrixBase::makeHouseholder()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#aebf4bac7dffe2685ab93734fb776e817" title="Computes the elementary reflector H such that:  where the transformation H is:  and the vector v is: ...">MatrixBase::makeHouseholderInPlace()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8f2c8059ef3f04cfa0c73b4c012db855" title="Apply the elementary reflector H given by  with  from the left to a vector or matrix.">MatrixBase::applyHouseholderOnTheLeft()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a08ad41e81d8ad4a37b5d5c7490e765"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="ae669131f6e18f7e8f06fae271754f435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the rotation in the plane <em>j</em> to the rows <em>p</em> and <em>q</em> of <code>*this</code>, i.e., it computes B = J * B, with <img class="formulaInl" alt="$ B = \left ( \begin{array}{cc} \text{*this.row}(p) \\ \text{*this.row}(q) \end{array} \right ) $" src="form_162.png"/>. </p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a45d91752925d2757fc8058a293b15462" title="replaces *this by *this * other.">MatrixBase::applyOnTheRight()</a>, internal::apply_rotation_in_the_plane() </dd></dl>

</div>
</div>
<a class="anchor" id="a45d91752925d2757fc8058a293b15462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>. </p>
<p>It is equivalent to <a class="el" href="class_eigen_1_1_matrix_base.html#a3783b6168995ca117a1c19fea3630ac4" title="replaces *this by *this * other.">MatrixBase::operator*=()</a> </p>

</div>
</div>
<a class="anchor" id="aa07f741c86219601664433777827bf1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the rotation in the plane <em>j</em> to the columns <em>p</em> and <em>q</em> of <code>*this</code>, i.e., it computes B = B * J with <img class="formulaInl" alt="$ B = \left ( \begin{array}{cc} \text{*this.col}(p) &amp; \text{*this.col}(q) \end{array} \right ) $" src="form_163.png"/>. </p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a3a08ad41e81d8ad4a37b5d5c7490e765" title="replaces *this by *this * other.">MatrixBase::applyOnTheLeft()</a>, internal::apply_rotation_in_the_plane() </dd></dl>

</div>
</div>
<a class="anchor" id="a354c33eec32ceb4193d002f4d41c0497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_array_wrapper.html">ArrayWrapper</a>&lt;Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="class_eigen_1_1_array_base.html">Array </a> expression of this matrix </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_array_base.html#af01e9ea8087e390af8af453bbe4c276c">ArrayBase::matrix()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab757d5801a0e038f8555635f06456352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a>&lt; const Derived &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::asDiagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pseudo-expression of a diagonal matrix with *this as vector of diagonal coefficients</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_diagonal_wrapper.html" title="Expression of a diagonal matrix.">DiagonalWrapper</a>, class <a class="el" href="class_eigen_1_1_diagonal_matrix.html" title="Represents a diagonal matrix with its storage.">DiagonalMatrix</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">diagonal()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a4b671f154dac9f7c6d03fdb9e5f9fab4">isDiagonal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a13b5c6cebebe3c6b70eb64dfbaa6fb13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomBinaryOp , typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;CustomBinaryOp, const Derived, const OtherDerived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::binaryExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomBinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomBinaryOp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the difference of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to substract a given scalar from all coefficients, see <a class="el" href="class_eigen_1_1_cwise.html#ab4f2e1a681dcb3a214e00ea8df0a5049">Cwise::operator-()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae3955c1440eacc31034a9b0ba61bd055" title="replaces *this by *this - other.">operator-=()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an expression of the sum of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to add a given scalar to all coefficients, see <a class="el" href="class_eigen_1_1_cwise.html#abdecdd6614d5f83f62506bee7ac6f6ac">Cwise::operator+()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#af8c1c2392d6d04b552a478ec3f82c511" title="replaces *this by *this + other.">operator+=()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise operator <em>func</em> of *this and <em>other</em> </dd></dl>
<p>The template parameter <em>CustomBinaryOp</em> is the type of the functor of the custom operator (see class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a> for an example)</p>
<p>Here is an example illustrating the use of custom functors: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="class_eigen_1_1_cwise.html#ae3ebfb798683c224a3b4f25a4a35073d">operator+()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae88c754cead815f8e40e006457a618e2">operator-()</a>, cwiseProduct() </dd></dl>

</div>
</div>
<a class="anchor" id="ad1c25fe03a20483e148eeaf800e5c94e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;::Real <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::blueNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>l2</em> norm of <code>*this</code> using the Blue's algorithm. A Portable Fortran Program to Find the Euclidean Norm of a Vector, ACM TOMS, Vol 4, Issue 1, 1978.</dd></dl>
<p>For architecture/scalar types without vectorization, this version is much faster than <a class="el" href="class_eigen_1_1_matrix_base.html#a7f2491064a05310dd3f331eac31e8aba">stableNorm()</a>. Otherwise the <a class="el" href="class_eigen_1_1_matrix_base.html#a7f2491064a05310dd3f331eac31e8aba">stableNorm()</a> is faster.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a7f2491064a05310dd3f331eac31e8aba">stableNorm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ade6da450b7538549cfc5d4a9e3cf1ffa">hypotNorm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b476d26afcd3d6d99282efe43d4a04d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::cast_return_type&lt;Derived,const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_cast_op&lt;typename internal::traits&lt;Derived&gt;::Scalar, NewType&gt;, const Derived&gt; &gt;::type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with the <em>Scalar</em> type casted to <em>NewScalar</em>.</dd></dl>
<p>The template parameter <em>NewScalar</em> is the type we are casting the scalars to.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_unary_op.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression.">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a914ea9742e139148b2b1a0b13d2280e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_col_piv_householder_q_r.html">ColPivHouseholderQR</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::colPivHouseholderQr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the column-pivoting Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_col_piv_householder_q_r.html" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a00a6327048607951e172ca03659ba16c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::computeInverseAndDetWithCheck </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ResultType::Scalar &amp;&#160;</td>
          <td class="paramname"><em>determinant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>invertible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>absDeterminantThreshold</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Computation of matrix inverse and determinant, with invertibility check.</p>
<p>This is only for fixed-size square matrices of size up to 4x4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>Reference to the matrix in which to store the inverse. </td></tr>
    <tr><td class="paramname">determinant</td><td>Reference to the variable in which to store the inverse. </td></tr>
    <tr><td class="paramname">invertible</td><td>Reference to the bool variable in which to store whether the matrix is invertible. </td></tr>
    <tr><td class="paramname">absDeterminantThreshold</td><td>Optional parameter controlling the invertibility check. The matrix will be declared invertible if the absolute value of its determinant is greater than this threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a721714321d5f2946c13767c193739c1a">inverse()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a51f4efbb1f5b83187d723e4f33fd3954">computeInverseWithCheck()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51f4efbb1f5b83187d723e4f33fd3954"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::computeInverseWithCheck </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>invertible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>absDeterminantThreshold</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Computation of matrix inverse, with invertibility check.</p>
<p>This is only for fixed-size square matrices of size up to 4x4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>Reference to the matrix in which to store the inverse. </td></tr>
    <tr><td class="paramname">invertible</td><td>Reference to the bool variable in which to store whether the matrix is invertible. </td></tr>
    <tr><td class="paramname">absDeterminantThreshold</td><td>Optional parameter controlling the invertibility check. The matrix will be declared invertible if the absolute value of its determinant is greater than this threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a721714321d5f2946c13767c193739c1a">inverse()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a00a6327048607951e172ca03659ba16c">computeInverseAndDetWithCheck()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae53e8680069efaf279a7b822e068d6d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">ConjugateReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the complex conjugate of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a3ab76dee1a5bf179ad4dcaa437179851">adjoint()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a67b453529e54476b660575bcfcd51d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template cross_product_return_type&lt; OtherDerived &gt;::type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the cross product of <code>*this</code> and <em>other</em> </dd></dl>
<p>Here is a very good explanation of cross-product: <a href="http://xkcd.com/199/">http://xkcd.com/199/</a> </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8416e098f4a05f7576993933e0542153">MatrixBase::cross3()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8416e098f4a05f7576993933e0542153"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cross3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the cross product of <code>*this</code> and <em>other</em> using only the x, y, and z coefficients</dd></dl>
<p>The size of <code>*this</code> and <em>other</em> must be four. This function is especially useful when using 4D vectors instead of 3D ones to get advantage of SSE/AltiVec vectorization.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a67b453529e54476b660575bcfcd51d3a">MatrixBase::cross()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3f273a7dd8a5516efc6f341b54bb8da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_abs_op&lt;Scalar&gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise absolute value of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aa3cb4a5267895e3abb29c309448f0c48">cwiseAbs2()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa3cb4a5267895e3abb29c309448f0c48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_abs2_op&lt;Scalar&gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseAbs2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise squared absolute value of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a3f273a7dd8a5516efc6f341b54bb8da9">cwiseAbs()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad0a92b34afd2680074f5222f2b41cb5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;std::equal_to&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#af74a7bd14e28fc41c28c3a89de8eb441">cwiseNotEqual()</a>, <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a>, isMuchSmallerThan() </dd></dl>

</div>
</div>
<a class="anchor" id="ae7d992e31d479d0c4e6d47f7bab493ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;std::binder1st&lt;std::equal_to&lt;Scalar&gt; &gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of <code>*this</code> and a scalar <em>s</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad0a92b34afd2680074f5222f2b41cb5e">cwiseEqual(const MatrixBase&lt;OtherDerived&gt; &amp;) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6111ce244aeb4698ae56604f8d211032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_inverse_op&lt;Scalar&gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise inverse of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>cwiseProduct() </dd></dl>

</div>
</div>
<a class="anchor" id="abcdafef370036f7161371e959242a25c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="group__min_max.html#ga35bfce232c4bad6d9007353a5d9ca82d" title="Compute the minimum entry of x.">min()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7b65e9413b8b9bb21a57ac7b3154811"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;Scalar&gt;, const Derived, const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="group__min_max.html#ga35bfce232c4bad6d9007353a5d9ca82d" title="Compute the minimum entry of x.">min()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab9971741beb0966b2cfbe10af0eee20f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="group__min_max.html#ga3b2c7ac8598ea7646f01cdd147d015e8" title="Compute the maximum entry of x.">max()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acbec7680109788bfa5a366ddd7e7a33e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;Scalar&gt;, const Derived, const <a class="el" href="class_eigen_1_1_cwise_nullary_op.html">ConstantReturnType</a>&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="group__min_max.html#ga35bfce232c4bad6d9007353a5d9ca82d" title="Compute the minimum entry of x.">min()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af74a7bd14e28fc41c28c3a89de8eb441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;std::not_equal_to&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseNotEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise != operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ae7d992e31d479d0c4e6d47f7bab493ba">cwiseEqual()</a>, <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a>, isMuchSmallerThan() </dd></dl>

</div>
</div>
<a class="anchor" id="a0274c10f4f3e1cb1f66225a660ad178b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseQuotient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise quotient of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, cwiseProduct(), <a class="el" href="class_eigen_1_1_matrix_base.html#a6111ce244aeb4698ae56604f8d211032">cwiseInverse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa95b94aabe162300d6d70a7c7d762751"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_sqrt_op&lt;Scalar&gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseSqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise square root of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>cwisePow(), cwiseSquare() </dd></dl>

</div>
</div>
<a class="anchor" id="a683482f8bdb56f34d840dc5f531943f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the determinant of this matrix </dd></dl>

</div>
</div>
<a class="anchor" id="ad0af691da3743e8a0154dfdebef745fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template DiagonalIndexReturnType&lt; <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the main diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_diagonal.html" title="Expression of a diagonal/subdiagonal/superdiagonal in a matrix.">Diagonal</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>DiagIndex-th</em> sub or super diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>The template parameter <em>DiagIndex</em> represent a super diagonal if <em>DiagIndex</em> &gt; 0 and a sub diagonal otherwise. <em>DiagIndex</em> == 0 is equivalent to the main diagonal.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">MatrixBase::diagonal()</a>, class <a class="el" href="class_eigen_1_1_diagonal.html" title="Expression of a diagonal/subdiagonal/superdiagonal in a matrix.">Diagonal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa82c14e48e0158255dc1e8ddbee13f54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template ConstDiagonalIndexReturnType&lt; <a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the const version of <a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">diagonal()</a>. </p>
<p>This is the const version of <a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">diagonal&lt;int&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="adc484e35fe942b1311731ed98caa5fe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template DiagonalIndexReturnType&lt; Dynamic &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>DiagIndex-th</em> sub or super diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>The template parameter <em>DiagIndex</em> represent a super diagonal if <em>DiagIndex</em> &gt; 0 and a sub diagonal otherwise. <em>DiagIndex</em> == 0 is equivalent to the main diagonal.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">MatrixBase::diagonal()</a>, class <a class="el" href="class_eigen_1_1_diagonal.html" title="Expression of a diagonal/subdiagonal/superdiagonal in a matrix.">Diagonal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2cac003afc562e2c3362eef006c67da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template ConstDiagonalIndexReturnType&lt; Dynamic &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the const version of <a class="el" href="class_eigen_1_1_matrix_base.html#adc484e35fe942b1311731ed98caa5fe0">diagonal(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a1b9b16405d3aa78bb634df74497af05e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the main diagonal, which is min(rows(),cols()). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>rows(), cols(), <a class="el" href="class_eigen_1_1_dense_base.html#a955028c4d9181328a799a9ac6b5068bfa25cb495affdbd796198462b8ef06be91" title="This is equal to the number of coefficients, i.e.">SizeAtCompileTime</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a710ab02d921af5783310144383c285fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::scalar_product_traits&lt; typename internal::traits&lt; Derived &gt;::Scalar, typename internal::traits&lt; OtherDerived &gt;::Scalar &gt;::ReturnType <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the dot product of *this with other.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the scalar type is complex numbers, then this function returns the hermitian (sesquilinear) dot product, conjugate-linear in the first variable and linear in the second variable.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aff809586e6babaa7821d5978517989d6">squaredNorm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0644598abdc92e666504f710ac9fda2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::EIGEN_CWISE_PRODUCT_RETURN_TYPE </td>
          <td>(</td>
          <td class="paramtype">Derived&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherDerived&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Schur product (coefficient wise product) of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#aa3cb4a5267895e3abb29c309448f0c48">cwiseAbs2</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbfe1f257e53611dc9ca1a7e9fe81854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix.html">EigenvaluesReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::eigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues of a matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Column vector containing the eigenvalues.</dd></dl>
<p>This function computes the eigenvalues with the help of the <a class="el" href="class_eigen_1_1_eigen_solver.html">EigenSolver</a> class (for real matrices) or the <a class="el" href="class_eigen_1_1_complex_eigen_solver.html">ComplexEigenSolver</a> class (for complex matrices).</p>
<p>The eigenvalues are repeated according to their algebraic multiplicity, so there are as many eigenvalues as rows in the matrix.</p>
<p>The <a class="el" href="class_eigen_1_1_self_adjoint_view.html" title="Expression of a selfadjoint matrix from a triangular part of a dense matrix.">SelfAdjointView</a> class provides a better algorithm for selfadjoint matrices.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_eigen_solver.html#a6075e8bbebc162e91c3e092dedc718b3" title="Returns the eigenvalues of given matrix.">EigenSolver::eigenvalues()</a>, <a class="el" href="class_eigen_1_1_complex_eigen_solver.html#a7b0d9c8700a8386af15cbbf078cc428c" title="Returns the eigenvalues of given matrix.">ComplexEigenSolver::eigenvalues()</a>, <a class="el" href="class_eigen_1_1_self_adjoint_view.html#ad4ebbcc3e7de8158830b841423aab501" title="Computes the eigenvalues of a matrix.">SelfAdjointView::eigenvalues()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a963cddf8d98590ef850ba18383e89fa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a748ec59de03a5c51cc6acd3fe1f2ca06">forceAlignedAccessIf()</a>,class <a class="el" href="class_eigen_1_1_force_aligned_access.html" title="Enforce aligned packet loads and stores regardless of what is requested.">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afdaf810ac1708ca6d6ecdcfac1e06699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a748ec59de03a5c51cc6acd3fe1f2ca06">forceAlignedAccessIf()</a>, class <a class="el" href="class_eigen_1_1_force_aligned_access.html" title="Enforce aligned packet loads and stores regardless of what is requested.">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad9d6ed8808adeee9cd51da20563a9da7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;bool Enable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::add_const_on_value_type&lt; typename internal::conditional&lt; Enable, <a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt;, Derived &amp; &gt;::type &gt;::type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccessIf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access if <em>Enable</em> is true. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#afdaf810ac1708ca6d6ecdcfac1e06699">forceAlignedAccess()</a>, class <a class="el" href="class_eigen_1_1_force_aligned_access.html" title="Enforce aligned packet loads and stores regardless of what is requested.">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a748ec59de03a5c51cc6acd3fe1f2ca06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;bool Enable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::conditional&lt; Enable, <a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a>&lt; Derived &gt;, Derived &amp; &gt;::type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccessIf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access if <em>Enable</em> is true. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#afdaf810ac1708ca6d6ecdcfac1e06699">forceAlignedAccess()</a>, class <a class="el" href="class_eigen_1_1_force_aligned_access.html" title="Enforce aligned packet loads and stores regardless of what is requested.">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a35969f2f99e43ba78ed63d5e941f89ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_full_piv_householder_q_r.html">FullPivHouseholderQR</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::fullPivHouseholderQr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the full-pivoting Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_full_piv_householder_q_r.html" title="Householder rank-revealing QR decomposition of a matrix with full pivoting.">FullPivHouseholderQR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a08113a4812ac99b7105b7556804dca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_full_piv_l_u.html">FullPivLU</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::fullPivLu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the full-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_full_piv_l_u.html" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a788456a7bea3452aae2791c47c96538d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_cwise_unary_op.html">HNormalizedReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::hnormalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the homogeneous normalized vector of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_vectorwise_op.html#a65ae1e206df43702639da5d9c0c9e471">VectorwiseOp::hnormalized()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1c181bbbb7457c6cfa5f31a73ab8c070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_householder_q_r.html">HouseholderQR</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::householderQr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_householder_q_r.html" title="Householder QR decomposition of a matrix.">HouseholderQR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade6da450b7538549cfc5d4a9e3cf1ffa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;::Real <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::hypotNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>l2</em> norm of <code>*this</code> avoiding undeflow and overflow. This version use a concatenation of hypot() calls, and it is very slow.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a7f2491064a05310dd3f331eac31e8aba">stableNorm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a040dec5c5a3525b649fb6e3a996bde6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_cwise_nullary_op.html">IdentityReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the identity matrix (not necessarily square).</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variant taking size arguments.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#af64da0ae7a79293f9934ce5084654e77">Identity(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a306742007396d5350c7830b1c3bebfbc" title="Writes the identity expression (not necessarily square) into *this.">setIdentity()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae02c24b6cece07dc777dea7a2eb67524">isIdentity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af64da0ae7a79293f9934ce5084654e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_cwise_nullary_op.html">IdentityReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the identity matrix (not necessarily square).</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="class_eigen_1_1_matrix_base.html#a040dec5c5a3525b649fb6e3a996bde6a">Identity()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a040dec5c5a3525b649fb6e3a996bde6a">Identity()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a306742007396d5350c7830b1c3bebfbc" title="Writes the identity expression (not necessarily square) into *this.">setIdentity()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae02c24b6cece07dc777dea7a2eb67524">isIdentity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c62c9f2e33ddfe33d53c4d8a3b0d485"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">ImagReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an read-only expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aeba1be140ede8b142460b325945c551f">real()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae468f7f102d5f04f20b2c0afe6eb0f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_cwise_unary_view.html">NonConstImagReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aeba1be140ede8b142460b325945c551f">real()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a721714321d5f2946c13767c193739c1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const internal::inverse_impl&lt; Derived &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the matrix inverse of this matrix.</dd></dl>
<p>For small fixed sizes up to 4x4, this method uses cofactors. In the general case, this method uses class <a class="el" href="class_eigen_1_1_partial_piv_l_u.html" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This matrix must be invertible, otherwise the result is undefined. If you need an invertibility check, do the following: <ul>
<li>for fixed sizes up to 4x4, use <a class="el" href="class_eigen_1_1_matrix_base.html#a00a6327048607951e172ca03659ba16c">computeInverseAndDetWithCheck()</a>. </li>
<li>for the general case, use class <a class="el" href="class_eigen_1_1_full_piv_l_u.html" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a>.</li>
</ul>
Example: <div class="fragment"></div><!-- fragment --> Output: <pre class="fragment"></pre></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a00a6327048607951e172ca03659ba16c">computeInverseAndDetWithCheck()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b671f154dac9f7c6d03fdb9e5f9fab4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">RealScalar&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to a diagonal matrix, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ab757d5801a0e038f8555635f06456352">asDiagonal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae02c24b6cece07dc777dea7a2eb67524"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isIdentity </td>
          <td>(</td>
          <td class="paramtype">RealScalar&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the identity matrix (not necessarily square), within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_nullary_op.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a040dec5c5a3525b649fb6e3a996bde6a">Identity()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#af64da0ae7a79293f9934ce5084654e77">Identity(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a306742007396d5350c7830b1c3bebfbc" title="Writes the identity expression (not necessarily square) into *this.">setIdentity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2adf4d2f4b0b4c97c600e16871f8d2fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isLowerTriangular </td>
          <td>(</td>
          <td class="paramtype">RealScalar&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to a lower triangular matrix, within the precision given by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a309cfe63c77116ebc0a3e909c767890e">isUpperTriangular()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9adf53ddc0888a91de6e8dba56113c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isOrthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealScalar&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately orthogonal to <em>other</em>, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre> 
</div>
</div>
<a class="anchor" id="a56c6a2f3e6953c7dcd8e8284b3633b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isUnitary </td>
          <td>(</td>
          <td class="paramtype">RealScalar&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately an unitary matrix, within the precision given by <em>prec</em>. In the case where the <em>Scalar</em> type is real numbers, a unitary matrix is an orthogonal matrix, whence the name.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can be used to check whether a family of vectors forms an orthonormal basis. Indeed, <code>m.isUnitary()</code> returns true if and only if the columns (equivalently, the rows) of m form an orthonormal basis.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre> 
</div>
</div>
<a class="anchor" id="a309cfe63c77116ebc0a3e909c767890e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">RealScalar&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to an upper triangular matrix, within the precision given by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a2adf4d2f4b0b4c97c600e16871f8d2fa">isLowerTriangular()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a662630cec4376bb127527856382828a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_jacobi_s_v_d.html">JacobiSVD</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::jacobiSvd </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>computationOptions</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the singular value decomposition of <code>*this</code> computed by two-sided Jacobi transformations.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_jacobi_s_v_d.html" title="Two-sided Jacobi SVD decomposition of a rectangular matrix.">JacobiSVD</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7855bab2b66967edd4b9b38f63bbb73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const LazyProductReturnType&lt; Derived, OtherDerived &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::lazyProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix product of <code>*this</code> and <em>other</em> without implicit evaluation.</dd></dl>
<p>The returned product will behave like any other expressions: the coefficients of the product will be computed once at a time as requested. This might be useful in some extremely rare cases when only a small and no coherent fraction of the result's coefficients have to be computed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the matrix product can be much much slower. So use it only if you know what you are doing and that you measured a true speed improvement.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>operator*(const MatrixBase&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a3ac6952b6c24cfbd171f6e3774098a7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_l_d_l_t.html">LDLT</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::ldlt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the Cholesky decomposition with full pivoting without square root of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6655385ff1d96c949f0690ef88bdef6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_l_l_t.html">LLT</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::llt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a> decomposition of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f6439765c982bbf208379b7c8dc726d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;::Real <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::lpNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <img class="formulaInl" alt="$ \ell^p $" src="form_10.png"/> norm of *this, that is, returns the p-th root of the sum of the p-th powers of the absolute values of the coefficients of *this. If <em>p</em> is the special value <em>Eigen::Infinity</em>, this function returns the <img class="formulaInl" alt="$ \ell^\infty $" src="form_11.png"/> norm, that is the maximum of the absolute values of the coefficients of *this.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aae79b7749f8085b3170e64d3750b237c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename EssentialPart &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::makeHouseholder </td>
          <td>(</td>
          <td class="paramtype">EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealScalar &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the elementary reflector H such that: <img class="formulaInl" alt="$ H *this = [ beta 0 ... 0]^T $" src="form_138.png"/> where the transformation H is: <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_139.png"/> and the vector v is: <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_140.png"/>. </p>
<p>On output: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">beta</td><td>the result of H * <code>*this</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aebf4bac7dffe2685ab93734fb776e817" title="Computes the elementary reflector H such that:  where the transformation H is:  and the vector v is: ...">MatrixBase::makeHouseholderInPlace()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8f2c8059ef3f04cfa0c73b4c012db855" title="Apply the elementary reflector H given by  with  from the left to a vector or matrix.">MatrixBase::applyHouseholderOnTheLeft()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab3e52262b41fa40e194dda245e0f9675" title="Apply the elementary reflector H given by  with  from the right to a vector or matrix.">MatrixBase::applyHouseholderOnTheRight()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aebf4bac7dffe2685ab93734fb776e817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::makeHouseholderInPlace </td>
          <td>(</td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealScalar &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the elementary reflector H such that: <img class="formulaInl" alt="$ H *this = [ beta 0 ... 0]^T $" src="form_138.png"/> where the transformation H is: <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_139.png"/> and the vector v is: <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_140.png"/>. </p>
<p>The essential part of the vector <code>v</code> is stored in *this.</p>
<p>On output: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">beta</td><td>the result of H * <code>*this</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#aae79b7749f8085b3170e64d3750b237c" title="Computes the elementary reflector H such that:  where the transformation H is:  and the vector v is: ...">MatrixBase::makeHouseholder()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8f2c8059ef3f04cfa0c73b4c012db855" title="Apply the elementary reflector H given by  with  from the left to a vector or matrix.">MatrixBase::applyHouseholderOnTheLeft()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab3e52262b41fa40e194dda245e0f9675" title="Apply the elementary reflector H given by  with  from the right to a vector or matrix.">MatrixBase::applyHouseholderOnTheRight()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2c1085de7645f23f240876388457da0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_no_alias.html">NoAlias</a>&lt; Derived, <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::noalias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pseudo expression of <code>*this</code> with an operator= assuming no aliasing between <code>*this</code> and the source expression.</dd></dl>
<p>More precisely, <a class="el" href="class_eigen_1_1_matrix_base.html#a2c1085de7645f23f240876388457da0b">noalias()</a> allows to bypass the EvalBeforeAssignBit flag. Currently, even though several expressions may alias, only product expressions have this flag. Therefore, <a class="el" href="class_eigen_1_1_matrix_base.html#a2c1085de7645f23f240876388457da0b">noalias()</a> is only usefull when the source expression contains a matrix product.</p>
<p>Here are some examples where noalias is usefull: </p>
<div class="fragment"><div class="line">D.noalias()  = A * B;</div>
<div class="line">D.noalias() += A.transpose() * B;</div>
<div class="line">D.noalias() -= 2 * A * B.adjoint();</div>
</div><!-- fragment --><p>On the other hand the following example will lead to a <b>wrong</b> result: </p>
<div class="fragment"><div class="line">A.noalias() = A * B;</div>
</div><!-- fragment --><p> because the result matrix A is also an operand of the matrix product. Therefore, there is no alternative than evaluating A * B in a temporary, that is the default behavior when you write: </p>
<div class="fragment"><div class="line">A = A * B;</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_no_alias.html" title="Pseudo expression providing an operator = assuming no aliasing.">NoAlias</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8c247d700df304eb9a560bab60335ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;::Real <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>, for vectors, the <em>l2</em> norm of <code>*this</code>, and for matrices the Frobenius norm. In both cases, it consists in the square root of the sum of the square of all the matrix entries. For vectors, this is also equals to the square root of the dot product of <code>*this</code> with itself.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a710ab02d921af5783310144383c285fc">dot()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#aff809586e6babaa7821d5978517989d6">squaredNorm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad16303c47ba36f7a41ea264cb26bceb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes the vector, i.e. </p>
<p>divides it by its own norm.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a680e8b0963abb141fc572c2d37d0496a">normalized()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a680e8b0963abb141fc572c2d37d0496a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::normalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the quotient of *this by its own norm.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ad16303c47ba36f7a41ea264cb26bceb6" title="Normalizes the vector, i.e.">normalize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7329f46e18c431c6dc5271aa4818bdb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if at least one pair of coefficients of <code>*this</code> and <em>other</em> are not exactly equal to each other. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a>, operator== </dd></dl>

</div>
</div>
<a class="anchor" id="a30b10cc7219c481fa40db0bb5781f56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">ScalarMultipleReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> scaled by the scalar factor <em>scalar</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a3da22f27a3829b54c096f655283d7ae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_multiple2_op&lt;Scalar,std::complex&lt;Scalar&gt; &gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded for efficient real matrix times complex scalar value. </p>

</div>
</div>
<a class="anchor" id="ad31953af786d8bef8335503ad31c0f75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt;Derived&gt;::<a class="el" href="class_eigen_1_1_cwise_unary_op.html">ScalarMultipleReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const UniformScaling&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a linear transformation matrix and a uniform scaling. </p>

</div>
</div>
<a class="anchor" id="a772e2b44c48aa96996febcb9b05b8215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_eigen_1_1_product_return_type.html">ProductReturnType</a>&lt; Derived, OtherDerived &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix product of <code>*this</code> and <em>other</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If instead of the matrix product you want the coefficient-wise product, see Cwise::operator*().</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad7855bab2b66967edd4b9b38f63bbb73">lazyProduct()</a>, operator*=(const MatrixBase&amp;), Cwise::operator*() </dd></dl>

</div>
</div>
<a class="anchor" id="a7de55e67af91d0bc9fc077a4a3029f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename DiagonalDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DiagonalProduct&lt; Derived, DiagonalDerived, OnTheRight &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const DiagonalBase&lt; DiagonalDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the diagonal matrix product of <code>*this</code> by the diagonal matrix <em>diagonal</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3783b6168995ca117a1c19fea3630ac4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af8c1c2392d6d04b552a478ec3f82c511"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces <code>*this</code> by <code>*this</code> + <em>other</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae88c754cead815f8e40e006457a618e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_opposite_op&lt;typename internal::traits&lt;Derived&gt;::Scalar&gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the opposite of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3955c1440eacc31034a9b0ba61bd055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces <code>*this</code> by <code>*this</code> - <em>other</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a57482610af9f8a69baa0eb4f376d7b85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;internal::scalar_quotient1_op&lt;typename internal::traits&lt;Derived&gt;::Scalar&gt;, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> divided by the scalar value <em>scalar</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a0da30d0cb9a52a8b39e59d76b1765952"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special case of the template operator=, in order to prevent the compiler from generating a default operator= (issue hit with g++ 4.1) </p>

</div>
</div>
<a class="anchor" id="ae5f55a023e88f00d8335de9ca33c881c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if each coefficients of <code>*this</code> and <em>other</em> are all exactly equal. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_dense_base.html#a64b0e7d2caafcc08f1874c8cb589865f">isApprox()</a>, operator!= </dd></dl>

</div>
</div>
<a class="anchor" id="a11574afb358726e20951701e4190f337"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::RealScalar <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operatorNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2 operator norm. </p>
<dl class="section return"><dt>Returns</dt><dd>Operator norm of the matrix.</dd></dl>
<p>This function computes the L2 operator norm of a matrix, which is also known as the spectral norm. The norm of a matrix <img class="formulaInl" alt="$ A $" src="form_0.png"/> is defined to be </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \|A\|_2 = \max_x \frac{\|Ax\|_2}{\|x\|_2} \]" src="form_105.png"/>
</p>
<p> where the maximum is over all vectors and the norm on the right is the Euclidean vector norm. The norm equals the largest singular value, which is the square root of the largest eigenvalue of the positive semi-definite matrix <img class="formulaInl" alt="$ A^*A $" src="form_106.png"/>.</p>
<p>The current implementation uses the eigenvalues of <img class="formulaInl" alt="$ A^*A $" src="form_106.png"/>, as computed by <a class="el" href="class_eigen_1_1_self_adjoint_view.html#ad4ebbcc3e7de8158830b841423aab501" title="Computes the eigenvalues of a matrix.">SelfAdjointView::eigenvalues()</a>, to compute the operator norm of a matrix. The <a class="el" href="class_eigen_1_1_self_adjoint_view.html" title="Expression of a selfadjoint matrix from a triangular part of a dense matrix.">SelfAdjointView</a> class provides a better algorithm for selfadjoint matrices.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_self_adjoint_view.html#ad4ebbcc3e7de8158830b841423aab501" title="Computes the eigenvalues of a matrix.">SelfAdjointView::eigenvalues()</a>, <a class="el" href="class_eigen_1_1_self_adjoint_view.html#a66e8a2f1e2fccf66d384e79330af2baa" title="Computes the L2 operator norm.">SelfAdjointView::operatorNorm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac76ef5a9b6769b3e20ec6529cd3ca276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_partial_piv_l_u.html">PartialPivLU</a>&lt; typename <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> &gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::partialPivLu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the partial-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_partial_piv_l_u.html" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad10353dcb54de8fbe27619cffd7fced5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">RealReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ae468f7f102d5f04f20b2c0afe6eb0f82">imag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeba1be140ede8b142460b325945c551f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">NonConstRealReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ae468f7f102d5f04f20b2c0afe6eb0f82">imag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a306742007396d5350c7830b1c3bebfbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the identity expression (not necessarily square) into *this. </p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_nullary_op.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a040dec5c5a3525b649fb6e3a996bde6a">Identity()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#af64da0ae7a79293f9934ce5084654e77">Identity(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae02c24b6cece07dc777dea7a2eb67524">isIdentity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0851dcc7c82753eb3e341d99b691665a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes to the given size, and writes the identity expression (not necessarily square) into *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the new number of rows </td></tr>
    <tr><td class="paramname">cols</td><td>the new number of columns</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a306742007396d5350c7830b1c3bebfbc" title="Writes the identity expression (not necessarily square) into *this.">MatrixBase::setIdentity()</a>, class <a class="el" href="class_eigen_1_1_cwise_nullary_op.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a040dec5c5a3525b649fb6e3a996bde6a">MatrixBase::Identity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff809586e6babaa7821d5978517989d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;::Real <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::squaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>, for vectors, the squared <em>l2</em> norm of <code>*this</code>, and for matrices the Frobenius norm. In both cases, it consists in the sum of the square of all the matrix entries. For vectors, this is also equals to the dot product of <code>*this</code> with itself.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a710ab02d921af5783310144383c285fc">dot()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f2491064a05310dd3f331eac31e8aba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;::Real <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::stableNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>l2</em> norm of <code>*this</code> avoiding underflow and overflow. This version use a blockwise two passes algorithm: 1 - find the absolute largest coefficient <code>s</code> 2 - compute <img class="formulaInl" alt="$ s \Vert \frac{*this}{s} \Vert $" src="form_29.png"/> in a standard way</dd></dl>
<p>For architecture/scalar types supporting vectorization, this version is faster than <a class="el" href="class_eigen_1_1_matrix_base.html#ad1c25fe03a20483e148eeaf800e5c94e">blueNorm()</a>. Otherwise the <a class="el" href="class_eigen_1_1_matrix_base.html#ad1c25fe03a20483e148eeaf800e5c94e">blueNorm()</a> is much faster.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a8c247d700df304eb9a560bab60335ee1">norm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ad1c25fe03a20483e148eeaf800e5c94e">blueNorm()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ade6da450b7538549cfc5d4a9e3cf1ffa">hypotNorm()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1a27388d3d5b242e50ea06a0ebe866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE internal::traits&lt; Derived &gt;::Scalar <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the trace of <code>*this</code>, i.e. the sum of the coefficients on the main diagonal.</dd></dl>
<p><code>*this</code> can be any matrix, not necessarily square.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad0af691da3743e8a0154dfdebef745fa">diagonal()</a>, <a class="el" href="class_eigen_1_1_dense_base.html#ae893580d10226bcf2a4ccd8fa653e6c8">sum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a09be7b9dfc5dc6f201f9267f7c1cb950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;unsigned int Mode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template TriangularViewReturnType&lt; Mode &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::triangularView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a triangular view extracted from the current matrix</dd></dl>
<p>The parameter <em>Mode</em> can have the following values: <code>#Upper</code>, <code>#StrictlyUpper</code>, <code>#UnitUpper</code>, <code>#Lower</code>, <code>#StrictlyLower</code>, <code>#UnitLower</code>.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_triangular_view.html" title="Base class for triangular part in a matrix.">TriangularView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10f8b54a684c1b18c5b7a23b94f6a612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;unsigned int Mode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::template ConstTriangularViewReturnType&lt; Mode &gt;::Type <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::triangularView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the const version of <a class="el" href="class_eigen_1_1_matrix_base.html#a09be7b9dfc5dc6f201f9267f7c1cb950">MatrixBase::triangularView()</a> </p>

</div>
</div>
<a class="anchor" id="acbe602d55aa168bfbc48b71524f0710b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomUnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt;CustomUnaryOp, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::unaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomUnaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomUnaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a unary operator coefficient-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor implementing the unary operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CustomUnaryOp</td><td>Type of <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The function <code>ptr_fun()</code> from the C++ standard library can be used to make functors out of normal functions.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><p>Genuine functors allow for more possibilities, for instance it may contain a state.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_unary_op.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression.">CwiseUnaryOp</a>, class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a684d4b2ab4e7e9ed45ea2c4d78c16010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomViewOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_cwise_unary_view.html">CwiseUnaryView</a>&lt;CustomViewOp, const Derived&gt; <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::unaryViewExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomViewOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomViewOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The template parameter <em>CustomUnaryOp</em> is the type of the functor of the custom unary operator.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="class_eigen_1_1_cwise_unary_op.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression.">CwiseUnaryOp</a>, class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad28b888173c31bf111bff950ee7a7ac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the i-th unit (basis) vector.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ab70cc18783815a995aae33c0f230ad48">MatrixBase::Unit(Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a3738ca476bb8da822a88fc99e2278e45">MatrixBase::UnitX()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">MatrixBase::UnitY()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">MatrixBase::UnitZ()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab70cc18783815a995aae33c0f230ad48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_dense_base.html#ad772e0ab2eb84b25cec6410631e8fdde">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the i-th unit (basis) vector.</dd></dl>
<p>This variant is for fixed-size vector only.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad28b888173c31bf111bff950ee7a7ac6">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a3738ca476bb8da822a88fc99e2278e45">MatrixBase::UnitX()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">MatrixBase::UnitY()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">MatrixBase::UnitZ()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f98663efdef5673f69373796061116"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_matrix_base.html#a02545f8c3f4551e949c1ea0517a0d41c">PlainObject</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::unitOrthogonal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a unit vector which is orthogonal to <code>*this</code> </dd></dl>
<p>The size of <code>*this</code> must be at least 2. If the size is exactly 2, then the returned vector is a counter clock wise rotation of <code>*this</code>, i.e., (-y,x).<a class="el" href="class_eigen_1_1_matrix_base.html#a680e8b0963abb141fc572c2d37d0496a">normalized()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#a67b453529e54476b660575bcfcd51d3a">cross()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e38a13a3c774415076efb6a4402113e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the W axis unit vector (0,0,0,1)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad28b888173c31bf111bff950ee7a7ac6">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab70cc18783815a995aae33c0f230ad48">MatrixBase::Unit(Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">MatrixBase::UnitY()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">MatrixBase::UnitZ()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3738ca476bb8da822a88fc99e2278e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the X axis unit vector (1{,0}^*)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad28b888173c31bf111bff950ee7a7ac6">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab70cc18783815a995aae33c0f230ad48">MatrixBase::Unit(Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">MatrixBase::UnitY()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">MatrixBase::UnitZ()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9d96862654ea88a1cea066dbb894efc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Y axis unit vector (0,1{,0}^*)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad28b888173c31bf111bff950ee7a7ac6">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab70cc18783815a995aae33c0f230ad48">MatrixBase::Unit(Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">MatrixBase::UnitY()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">MatrixBase::UnitZ()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8eb31f6df86be131b52451dd2e979bc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_STRONG_INLINE const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="class_eigen_1_1_block.html">BasisReturnType</a> <a class="el" href="class_eigen_1_1_matrix_base.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Z axis unit vector (0,0,1{,0}^*)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_eigen_1_1_matrix_base.html#ad28b888173c31bf111bff950ee7a7ac6">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ab70cc18783815a995aae33c0f230ad48">MatrixBase::Unit(Index)</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#ae9d96862654ea88a1cea066dbb894efc">MatrixBase::UnitY()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a8eb31f6df86be131b52451dd2e979bc9">MatrixBase::UnitZ()</a>, <a class="el" href="class_eigen_1_1_matrix_base.html#a2e38a13a3c774415076efb6a4402113e">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>third_party/Eigen/src/Core/<a class="el" href="_matrix_base_8h_source.html">MatrixBase.h</a></li>
<li>third_party/Eigen/src/plugins/<a class="el" href="_common_cwise_unary_ops_8h_source.html">CommonCwiseUnaryOps.h</a></li>
<li>third_party/Eigen/src/plugins/<a class="el" href="_common_cwise_binary_ops_8h_source.html">CommonCwiseBinaryOps.h</a></li>
<li>third_party/Eigen/src/plugins/<a class="el" href="_matrix_cwise_unary_ops_8h_source.html">MatrixCwiseUnaryOps.h</a></li>
<li>third_party/Eigen/src/plugins/<a class="el" href="_matrix_cwise_binary_ops_8h_source.html">MatrixCwiseBinaryOps.h</a></li>
<li>third_party/Eigen/src/Cholesky/<a class="el" href="_l_d_l_t_8h_source.html">LDLT.h</a></li>
<li>third_party/Eigen/src/Cholesky/<a class="el" href="_l_l_t_8h_source.html">LLT.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_assign_8h_source.html">Assign.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_cwise_binary_op_8h_source.html">CwiseBinaryOp.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_cwise_nullary_op_8h_source.html">CwiseNullaryOp.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_diagonal_8h_source.html">Diagonal.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_diagonal_matrix_8h_source.html">DiagonalMatrix.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_diagonal_product_8h_source.html">DiagonalProduct.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_dot_8h_source.html">Dot.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_eigen_base_8h_source.html">EigenBase.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_force_aligned_access_8h_source.html">ForceAlignedAccess.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_general_product_8h_source.html">GeneralProduct.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_no_alias_8h_source.html">NoAlias.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_permutation_matrix_8h_source.html">PermutationMatrix.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_product_base_8h_source.html">ProductBase.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_redux_8h_source.html">Redux.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_self_adjoint_view_8h_source.html">SelfAdjointView.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_stable_norm_8h_source.html">StableNorm.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_transpose_8h_source.html">Transpose.h</a></li>
<li>third_party/Eigen/src/Core/<a class="el" href="_triangular_matrix_8h_source.html">TriangularMatrix.h</a></li>
<li>third_party/Eigen/src/Eigenvalues/<a class="el" href="_matrix_base_eigenvalues_8h_source.html">MatrixBaseEigenvalues.h</a></li>
<li>third_party/Eigen/src/Geometry/<a class="el" href="_euler_angles_8h_source.html">EulerAngles.h</a></li>
<li>third_party/Eigen/src/Geometry/<a class="el" href="_homogeneous_8h_source.html">Homogeneous.h</a></li>
<li>third_party/Eigen/src/Geometry/<a class="el" href="_ortho_methods_8h_source.html">OrthoMethods.h</a></li>
<li>third_party/Eigen/src/Geometry/<a class="el" href="_geometry_2_scaling_8h_source.html">Scaling.h</a></li>
<li>third_party/Eigen/src/Householder/<a class="el" href="_householder_8h_source.html">Householder.h</a></li>
<li>third_party/Eigen/src/Jacobi/<a class="el" href="_jacobi_8h_source.html">Jacobi.h</a></li>
<li>third_party/Eigen/src/LU/<a class="el" href="_determinant_8h_source.html">Determinant.h</a></li>
<li>third_party/Eigen/src/LU/<a class="el" href="_full_piv_l_u_8h_source.html">FullPivLU.h</a></li>
<li>third_party/Eigen/src/LU/<a class="el" href="_inverse_8h_source.html">Inverse.h</a></li>
<li>third_party/Eigen/src/LU/<a class="el" href="_partial_piv_l_u_8h_source.html">PartialPivLU.h</a></li>
<li>third_party/Eigen/src/QR/<a class="el" href="_col_piv_householder_q_r_8h_source.html">ColPivHouseholderQR.h</a></li>
<li>third_party/Eigen/src/QR/<a class="el" href="_full_piv_householder_q_r_8h_source.html">FullPivHouseholderQR.h</a></li>
<li>third_party/Eigen/src/QR/<a class="el" href="_householder_q_r_8h_source.html">HouseholderQR.h</a></li>
<li>third_party/Eigen/src/SparseCore/<a class="el" href="_sparse_view_8h_source.html">SparseView.h</a></li>
<li>third_party/Eigen/src/SVD/<a class="el" href="_jacobi_s_v_d_8h_source.html">JacobiSVD.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 3 2013 20:40:17 for NumCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
